underlines:
  under0: &under0 '^'
  under1: &under1 '~'
  under2: &under2 '-'

errors:
  -
    code: 0
    name: unexpected-char
    desc: The lexer found an unexpected character that could not begin a token.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"unexpected character"']
        ]]
  -
    code: 1
    name: unterm-charlit
    desc: The lexer found an unterminated character literal. A common cause of this is character literals that are more than one character long.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"unterminated character literal"']
        ]]
  -
    code: 2
    name: unterm-strlit
    desc: The lexer found a newline in a string literal, thereby making it unterminated. Newlines that need to appear inside the string literal must be escaped by putting `\n`.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"unterminated string literal"']
        ]]
  -
    code: 3
    name: invalid-intlit-base
    desc: The lexer found an integer literal that has an invalid base.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"invalid integer literal base"']
        ]]
  -
    code: 4
    name: nondecimal-floatlit
    desc: The lexer found a non-decimal floating point literal.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"invalid integer literal base"']
        ]]
  -
    code: 100
    name: unrecoverable-invalid-syntax-while
    desc: The parser found an unrecoverable syntax error, and has information about what construct was being parsed when the error happened.
    inputs: 'std::string const &justparsed, std::string const &expected, std::string const &whileparsing, Token const &last, Token const &lookahead'
    location: last
    highlights:
      - ['last', *under0, [
          ['error', 'concatMsg("expected ", expected, " after ", justparsed, " of ", whileparsing, ", but got ", stringifyTokenType(lookahead.type), " instead")']
        ]]
      - ['lookahead', *under1, [
          ['note', '"unexpected token here"']
        ]]
  - code: 101
    name: unrecoverable-invalid-syntax
    desc: The parser found an unrecoverable syntax error, and has conflicting information about what construct was being parsed when the error happened.
    inputs: 'std::string const &justparsed, std::string const &expected, Token const &last, Token const &lookahead'
    location: last
    highlights:
      - ['last', *under0, [
          ['error', 'concatMsg("expected ", expected, " after ", justparsed, ", but got ", stringifyTokenType(lookahead.type), " instead")']
        ]]
      - ['lookahead', *under1, [
          ['note', '"unexpected token here"']
        ]]
  -
    code: 102
    name: simple-invalid-syntax-while
    desc: The parser found a syntax error, has information about what construct was being parsed when the error happened, and recovered by inserting, substituting, or removing a single token.
    inputs: 'std::string const &justparsed, std::string const &expected, std::string const &whileparsing, Token const &last, Token const &lookahead, std::string const &bestfix'
    location: last
    highlights:
      - ['last', *under0, [
          ['error', 'concatMsg("expected ", expected, " after ", justparsed, " of ", whileparsing, ", but got ", stringifyTokenType(lookahead.type), " instead")']
        ]]
      - ['lookahead', *under1, [
          ['note', '"unexpected token here"'],
          ['hint', 'bestfix']
        ]]
  - code: 103
    name: simple-invalid-syntax
    desc: The parser found a syntax error, has conflicting information about what construct was being parsed when the error happened, and recovered by inserting, substituting, or removing a single token.
    inputs: 'std::string const &justparsed, std::string const &expected, Token const &last, Token const &lookahead, std::string const &bestfix'
    location: last
    highlights:
      - ['last', *under0, [
          ['error', 'concatMsg("expected ", expected, " after ", justparsed, ", but got ", stringifyTokenType(lookahead.type), " instead")']
        ]]
      - ['lookahead', *under1, [
          ['note', '"unexpected token here"'],
          ['hint', 'bestfix']
        ]]
  -
    code: 104
    name: panicking-invalid-syntax-while
    desc: The parser found a syntax error, has information about what construct was being parsed when the error happened, and recovered via panic mode error recovery.
    inputs: 'std::string const &justparsed, std::string const &expected, std::string const &whileparsing, Token const &last, Token const &lookahead'
    location: last
    highlights:
      - ['last', *under0, [
          ['error', 'concatMsg("expected ", expected, " after ", justparsed, " of ", whileparsing, ", but got ", stringifyTokenType(lookahead.type), " instead")']
        ]]
      - ['lookahead', *under1, [
          ['note', '"unexpected token here"']
        ]]
  -
    code: 105
    name: panicking-invalid-syntax
    desc: The parser found a syntax error, has conflicting information about what construct was being parsed when the error happened, and recovered via panic mode error recovery.
    inputs: 'std::string const &justparsed, std::string const &expected, Token const &last, Token const &lookahead'
    location: last
    highlights:
      - ['last', *under0, [
          ['error', 'concatMsg("expected ", expected, " after ", justparsed, ", but got ", stringifyTokenType(lookahead.type), " instead")']
        ]]
      - ['lookahead', *under1, [
          ['note', '"unexpected token here"']
        ]]
  -
    code: 200
    name: redecl-sym
    desc: Symbol was redeclared
    inputs: 'Token const &name, IR::Value *val'
    location: name
    highlights:
      - ['name', *under0, [
          ['error', '"redeclaration of symbol"']
        ]]
    extra: |
      IR::Function *asf (dynamic_cast<IR::Function*>(val));
      if (asf)
        e.underline(Error::Underline(asf->defAST(), '^')
          .note("previous declaration"));
  -
    code: 201
    name: lhs-unsupported-op
    desc: Left hand side of binary expression does not support operator
    inputs: 'IR::ASTValue const &lhs, IR::ASTValue const &rhs, Token const &op'
    location: op
    highlights:
      - ['lhs', *under0, [
          ['note', 'concatMsg("lhs is of type \"", lhs.type()->stringify(), "\"")']
        ]]
      - ['asdeclval->defAST()', *under1, [['note', '"lhs declared here"']], 'dyncast IR::DeclaredValue, asdeclval, lhs.val']
      - ['op', *under0, [
          ['error', '"unsupported binary operator for left operand"']
        ]]
      - ['rhs', *under1, []]

  -
    code: 203
    name: unary-unsupported-op
    desc: Operand of unary expression does not support operator
    inputs: 'IR::ASTValue const &operand, Token const &_operator'
    location: _operator
    highlights:
      - ['operand', *under0, [
          ['note', 'concatMsg("operand is of type \"", operand.type()->stringify(), "\"")']
        ]]
      - ['asdeclval->defAST()', *under1, [['note', '"operand declared here"']], 'dyncast IR::DeclaredValue, asdeclval, operand.val']
      - ['_operator', *under0, [
          ['error', '"unsupported unary operator"']
        ]]
  -
    code: 204
    name: call-noncallable
    desc: Non-callable value called
    inputs: 'IR::ASTValue const &func, Token const &oparn'
    location: oparn
    highlights:
      - ['func', *under0, [
          ['error', '"calling of non-callable value"']
        ]]
      - ['fdecl->defAST()', *under1, [['note', '"callee declared here"']], 'dyncast IR::DeclaredValue, fdecl, func.val']
  -
    code: 205
    name: wrong-num-args
    desc: Wrong number of arguments to function call
    inputs: 'IR::ASTValue const &func, Token const &oparn, ASTNS::ArgB *argsast, std::vector<IR::ASTValue> const &args'
    location: oparn
    highlights:
      - ['argsast', *under0, [
          ['error', '"wrong number of arguments to function call"']
        ]]
      - ['func', *under1, []]
      - ['static_cast<IR::Function*>(func.val)->defAST()', *under1, [
          ['note', 'concatMsg("function expects ", static_cast<IR::FunctionType*>(func.type())->paramtys.size(), " arguments, but got ", args.size(), "arguments")']
        ]]
  -
    code: 206
    name: incorrect-arg
    desc: Incorrect argument to function call
    inputs: 'IR::ASTValue const &arg, IR::Type const *expected'
    location: arg
    highlights:
      - ['arg', *under0, [
          ['error', '"invalid argument to function call"'],
          ['note', 'concatMsg("argument is of type \"", arg.type()->stringify(), "\"")'],
          ['note', 'concatMsg("function expects \"", expected->stringify(), "\"")'],
      ]]

  -
    code: 207
    name: undecl-symb
    desc: undeclared symbol
    inputs: 'Token const &sym'
    location: sym
    highlights:
      - ['sym', *under0, [
          ['error', '"undeclared symbol"']
        ]]
  -
    code: 208
    name: confl-tys-ternexpr
    desc: Conflicting types for ternary expression
    inputs: 'IR::ASTValue const &truev, IR::ASTValue const &falsev, Token const &quest'
    location: quest
    highlights:
      - ['quest', *under0, [
          ['error', '"conflicting types for ternary expression"']
        ]]
      - ['truev', *under1, [
          ['note', 'truev.type()->stringify()']
        ]]
      - ['falsev', *under1, [
          ['note', 'falsev.type()->stringify()']
        ]]
  -
    code: 209
    name: assign-invalid-lhs
    desc: Invalid assignment target
    inputs: 'Token const &eq, IR::ASTValue const &lhs'
    location: eq
    highlights:
      - ['eq', *under0, [
          ['error', '"non-lvalue assignment"']
        ]]
      - ['lhs', *under1, []]
  -
    code: 210
    name: assign-conflict-tys
    desc: Assignment target and value do not have same type
    inputs: 'IR::ASTValue const &lhs, IR::ASTValue const &rhs, Token const &eq'
    location: eq
    highlights:
      - ['eq', *under0, [
          ['error', '"conflicting types for assignment"']
        ]]
      - ['lhs', *under1, [
          ['note', 'lhs.type()->stringify()']
        ]]
      - ['rhs', *under1, [
          ['note', 'rhs.type()->stringify()']
        ]]
  -
    code: 211
    name: ret-val-void-fun
    desc: Return statement in void function
    inputs: 'IR::ASTValue const &val, IR::Function *f'
    location: val
    highlights:
      - ['val', *under0, [
          ['error', '"non-void return in void function"']
        ]]
      - ['f->defAST()->retty.get()', *under1, [
          ['note', '"function returns void"']
        ]]
  -
    code: 212
    name: conflict-ret-ty
    desc: Conflicting return types
    inputs: 'IR::ASTValue const &val, IR::Function *f'
    location: val
    highlights:
      - ['val', *under0, [
          ['error', '"conflicting return type"']
        ]]
      - ['f->defAST()->retty.get()', *under1, [
          ['note', 'concatMsg("function returns \"", f->ty->ret->stringify(), "\"")']
        ]]
  -
    code: 213
    name: ret-void-nonvoid-fun
    desc: Void return in non-void function
    inputs: 'ASTNS::AST *retstmt, IR::Function *f'
    location: retstmt
    highlights:
      - ['retstmt', *under0, [
          ['error', '"void return in non-void function"']
        ]]
      - ['f->defAST()->retty.get()', *under1, [
          ['note', 'concatMsg("function returns \"", f->ty->ret->stringify(), "\"")']
        ]]
  -
    code: 214
    name: redecl-var
    desc: Redeclaration of variable
    inputs: 'Token const &name, IR::Register const *prev'
    location: name
    highlights:
      - ['name', *under0, [
          ['error', '"redeclaration of variable"']
        ]]
      - ['prev->defAST()', *under1, [
          ['note', '"previous declaration"']
        ]]
  -
    code: 215
    name: conflict-var-init-ty
    desc: Conflicting type for variable initialization
    inputs: 'Token const &eq, Token const &name, IR::ASTValue const &init, IR::Register const *var'
    location: eq
    highlights:
      - ['eq', *under1, []]
      - ['init', *under0, [
          ['error', '"conflicting types for variable initialization"'],
          ['note', 'init.type()->stringify()']
        ]]
      - ['name', *under0, [
          ['note', 'var->type()->stringify()']
        ]]
  -
    code: 216
    name: invalid-cast
    desc: Invalid cast
    inputs: 'ASTNS::AST *ast, IR::ASTValue v, IR::Type const *newty'
    location: ast
    highlights:
      - ['ast', *under0, [
          ['error', '"invalid cast"'],
          ['note', 'concatMsg("from \"", v.type()->stringify(), "\" to \"", newty->stringify(), "\"")']
        ]]
  -
    code: 217
    name: conflict-tys-binary-op
    desc: Conflicting types to binary operator
    inputs: 'IR::ASTValue const &lhs, IR::ASTValue const &rhs, Token const &op'
    location: op
    highlights:
      - ['lhs', *under1, [
          ['note', 'lhs.type()->stringify()']
        ]]
      - ['rhs', *under1, [
          ['note', 'rhs.type()->stringify()']
        ]]
      - ['op', *under0, [
          ['error', '"conflicting types to binary operator"']
        ]]
