underlines:
  under0: &under0 '^'
  under1: &under1 '~'
  under2: &under2 '-'

errors:
  -
    code: 0
    name: unexpected-char
    desc: The lexer found an unexpected character that could not begin a token.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"unexpected character"']
        ]]
  -
    code: 1
    name: unterm-charlit
    desc: The lexer found an unterminated character literal.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"unterminated character literal"']
        ]]
  -
    code: 2
    name: unterm-strlit
    desc: The lexer found a newline in a string literal, thereby making it unterminated. # TODO:  Newlines that need to appear inside the string literal must be escaped by putting `\n`.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"unterminated string literal"']
        ]]
  -
    code: 3
    name: invalid-intlit-base
    desc: The lexer found an integer literal that has an invalid base.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"invalid integer literal base"']
        ]]
  -
    code: 4
    name: nondecimal-floatlit
    desc: The lexer found a non-decimal floating point literal.
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"invalid integer literal base"']
        ]]
  -
    code: 5
    name: invalid-char-floatlit
    desc: Invalid numeric character for floating point literal
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"invalid character in floating point literal"']
        ]]
  -
    code: 6
    name: invalid-char-for-base
    desc: Invalid numberic character in integer literal for base
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"invalid character in integer literal for base"']
        ]]
  -
    code: 7
    name: intlit-no-digits
    desc: Integer literal with no digits
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"integer literal with no digits"']
        ]]
  -
    code: 8
    name: multichar-charlit
    desc: Character literal with more than one character
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"character literal with more than one character"']
        ]]
  -
    code: 9
    name: unterm-multiline-comment
    desc: Unterminated multiline comment
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"unterminated multiline comment"']
        ]]
  -
    code: 10
    name: dedent-nomatch
    desc: Dedent level does not match any other indentation level
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"dedent to unknown level"']
        ]]
  -
    code: 11
    name: char-after-backslash
    desc: Non-newline after line continuation backslash
    inputs: 'Token const &tok'
    location: tok
    highlights:
      - ['tok', *under0, [
          ['error', '"non-newline after line continuation backslash"']
        ]]
  - code: 100
    name: unrecoverable-invalid-syntax
    desc: The parser found an unrecoverable syntax error.
    inputs: 'Token const &lookahead, Token const &lasttok, std::vector<std::string> const &expectations'
    location: lookahead
    highlights:
      - ['lookahead', *under0, [
          ['error', 'format("unexpected %", lookahead.type)'],
        ]]
    extra: |
      auto un (Error::Underline(lasttok, '~'));
      for (std::string const &expectation : expectations)
        un.hint(expectation);
      e.underline(un);
  - code: 101
    name: simple-invalid-syntax
    desc: The parser found a syntax error and recovered by inserting, substituting, or removing a single token.
    inputs: 'Token const &lookahead, Token const &lasttok, std::string const &bestfix, std::vector<std::string> const &expectations'
    location: lookahead
    highlights:
      - ['lookahead', *under0, [
          ['error', 'format("unexpected %", lookahead.type)'],
          ['note', 'bestfix']
        ]]
    extra: |
      auto un (Error::Underline(lasttok, '~'));
      for (std::string const &expectation : expectations)
        un.hint(expectation);
      e.underline(un);
  -
    code: 102
    name: panicking-invalid-syntax
    desc: The parser found a syntax error and recovered via panic mode error recovery.
    inputs: 'Token const &lookahead, Token const &lasttok, Token const &panicuntil, std::vector<std::string> const &expectations'
    location: lookahead
    highlights:
      - ['lookahead', *under0, [
          ['error', 'format("unexpected %", lookahead.type)'],
        ]]
      - ['panicuntil', *under2, [
          ['note', 'format("parser panicked until %", panicuntil.type)']
        ]]
    extra: |
      auto un (Error::Underline(lasttok, '~'));
      for (std::string const &expectation : expectations)
        un.hint(expectation);
      e.underline(un);
  -
    code: 200
    name: redecl-sym
    desc: Symbol was redeclared
    inputs: 'Token const &name, IR::Value *val'
    location: name
    highlights:
      - ['name', *under0, [
          ['error', '"redeclaration of symbol"']
        ]]
      - ['asdeclared->defAST()', *under1, [
          ['note', '"previous declaration"']
        ], 'dyncast IR::DeclaredValue, asdeclared, val']
  -
    code: 201
    name: lhs-unsupported-op
    desc: Left hand side of binary expression does not support operator
    inputs: 'IR::ASTValue const &lhs, Token const &op'
    location: op
    highlights:
      - ['lhs', *under0, [
          ['note', 'format("lhs is of type %", lhs.type())']
        ]]
      - ['asdeclared->defAST()', *under1, [['note', '"lhs declared here"']], 'dyncast IR::DeclaredValue, asdeclared, lhs.val']
      - ['op', *under0, [
          ['error', '"unsupported binary operator for left operand"']
        ]]
  -
    code: 202
    name: addrof-not-lvalue
    desc: Taking an address of a non-lvalue is impossible
    inputs: 'Token const &op, IR::ASTValue const &val'
    location: val
    highlights:
      - ['op', *under0, [
          ['error', '"taking address of non-lvalue"']
        ]]
      - ['val', *under1, []]
  -
    code: 203
    name: unary-unsupported-op
    desc: Operand of unary expression does not support operator
    inputs: 'IR::ASTValue const &operand, Token const &_operator'
    location: _operator
    highlights:
      - ['operand', *under0, [
          ['note', 'format("operand is of type %", operand.type())']
        ]]
      - ['asdeclared->defAST()', *under1, [['note', '"operand declared here"']], 'dyncast IR::DeclaredValue, asdeclared, operand.val']
      - ['_operator', *under0, [
          ['error', '"unsupported unary operator"']
        ]]
  -
    code: 204
    name: call-noncallable
    desc: Non-callable value called
    inputs: 'IR::ASTValue const &func, Token const &oparn'
    location: oparn
    highlights:
      - ['func', *under0, [
          ['error', '"calling of non-callable value"'],
          ['note', 'format("value of type %", func.type())']
        ]]
      - ['asdeclared->defAST()', *under1, [['note', '"callee declared here"']], 'dyncast IR::DeclaredValue, asdeclared, func.val']
  -
    code: 205
    name: wrong-num-args
    desc: Wrong number of arguments to function call
    inputs: 'IR::ASTValue const &func, Token const &oparn, ASTNS::ArgB *argsast, std::vector<IR::ASTValue> const &args'
    location: oparn
    highlights:
      - ['argsast ? Location(argsast) : Location(oparn)', *under0, [
          ['error', '"wrong number of arguments to function call"']
        ]]
      - ['func', *under1, []]
      - ['static_cast<IR::Function*>(func.val)->defAST()', *under1, [
          ['note', 'format("function expects % arguments, but got % arguments", static_cast<IR::FunctionType*>(func.type())->paramtys.size(), args.size())']
        ]]
  -
    code: 206
    name: incorrect-arg
    desc: Incorrect argument to function call
    inputs: 'IR::ASTValue const &arg, IR::Type const *expected'
    location: arg
    highlights:
      - ['arg', *under0, [
          ['error', '"invalid argument to function call"'],
          ['note', 'format("argument is of type %", arg.type())'],
          ['note', 'format("function expects %", expected)'],
      ]]

  -
    code: 207
    name: undecl-symb
    desc: Usage of undeclared symbol
    inputs: 'Token const &sym'
    location: sym
    highlights:
      - ['sym', *under0, [
          ['error', '"undeclared symbol"']
        ]]
  -
    code: 208
    name: confl-tys-ifexpr
    desc: Conflicting types for branches of if expression
    inputs: 'IR::ASTValue const &truev, IR::ASTValue const &falsev, Token const &iftok'
    location: iftok
    highlights:
      - ['iftok', *under0, [
          ['error', '"conflicting types for branches of if expression"']
        ]]
      - ['truev', *under1, [
          ['note', 'format("%", truev.type())']
        ]]
      - ['falsev', *under1, [
          ['note', 'format("%", falsev.type())']
        ]]
  -
    code: 209
    name: assign-invalid-lhs
    desc: Invalid assignment target
    inputs: 'Token const &eq, IR::ASTValue const &lhs'
    location: eq
    highlights:
      - ['eq', *under0, [
          ['error', '"non-lvalue assignment"']
        ]]
      - ['lhs', *under1, []]
  -
    code: 210
    name: assign-conflict-tys
    desc: Assignment target and value do not have same type
    inputs: 'IR::ASTValue const &lhs, IR::ASTValue const &rhs, Token const &eq'
    location: eq
    highlights:
      - ['eq', *under0, [
          ['error', '"conflicting types for assignment"']
        ]]
      - ['lhs', *under1, [
          ['note', 'format("%", lhs.type())']
        ]]
      - ['rhs', *under1, [
          ['note', 'format("%", rhs.type())']
        ]]
  -
    code: 212
    name: conflict-ret-ty
    desc: Conflicting return types
    inputs: 'IR::ASTValue const &val, IR::Function *f'
    location: val
    highlights:
      - ['val', *under0, [
          ['error', '"conflicting return type"'],
          ['note', 'format("returning %", val.type())']
        ]]
      - ['f->defAST()->retty.get()', *under1, [
          ['note', 'format("function returns %", f->ty->ret)']
        ]]
  -
    code: 213
    name: no-deref
    desc: Cannot dereference non-pointer
    inputs: 'Token const &op, IR::ASTValue const &val'
    location: val
    highlights:
      - ['op', *under0, [
          ['error', 'format("dereferencing of non-pointer type %", val.type())'],
        ]]
      - ['val', *under1, []]
  -
    code: 214
    name: redecl-var
    desc: Redeclaration of variable
    inputs: 'Token const &name, IR::Register const *prev'
    location: name
    highlights:
      - ['name', *under0, [
          ['error', '"redeclaration of variable"']
        ]]
      - ['prev->defAST()', *under1, [
          ['note', '"previous declaration"']
        ]]
  -
    code: 215
    name: conflict-var-init-ty
    desc: Conflicting type for variable initialization
    inputs: 'Token const &eq, Token const &name, IR::ASTValue const &init, IR::Register const *var'
    location: eq
    highlights:
      - ['eq', *under1, []]
      - ['init', *under0, [
          ['error', '"conflicting types for variable initialization"'],
          ['note', 'format("%", init.type())']
        ]]
      - ['name', *under0, [
          ['note', 'format("%", var->type())']
        ]]
  -
    code: 216
    name: invalid-cast
    desc: Invalid cast
    inputs: 'ASTNS::AST *ast, IR::ASTValue v, IR::Type const *newty'
    location: ast
    highlights:
      - ['ast', *under0, [
          ['error', 'format("invalid cast from % to %", v.type(), newty)'],
        ]]
  -
    code: 217
    name: conflict-tys-binary-op
    desc: Conflicting types to binary operator
    inputs: 'IR::ASTValue const &lhs, IR::ASTValue const &rhs, Token const &op'
    location: op
    highlights:
      - ['lhs', *under1, [
          ['note', 'format("%", lhs.type())']
        ]]
      - ['rhs', *under1, [
          ['note', 'format("%", rhs.type())']
        ]]
      - ['op', *under0, [
          ['error', '"conflicting types to binary operator"']
        ]]
  -
    code: 218
    name: redecl-param
    desc: Redeclaraion of parameter in function declaration
    inputs: 'Token const &name, IR::Register const *prev'
    location: name
    highlights:
      - ['name', *under0, [
          ['error', '"redeclaration of parameter"']
        ]]
      - ['prev->defAST()', *under1, [
          ['note', '"previous declaration"']
        ]]
  -
    code: 219
    name: cond-not-bool
    desc: Using a non-bool value as a condition
    inputs: 'IR::ASTValue &v'
    location: v
    highlights:
      - ['v', *under0, [
          ['error', 'format("usage of % as condition", v.type())']
        ]]
      - ['asdeclared->defAST()', *under1, [['note', '"declared here"']], 'dyncast IR::DeclaredValue, asdeclared, v.val']
  -
    code: 220
    name: no-else-not-void
    desc: If expression with non-void true expression and no else case
    inputs: 'IR::ASTValue const &truev, Token const &iftok'
    location: iftok
    highlights:
      - ['iftok', *under0, [
          ['error', '"if expression with non-void true expression and no else case"']
        ]]
      - ['truev', *under1, [
          ['note', 'format("%", truev.type())']
        ]]
