#include "message/errmsgs.h"
#include "message/errors.h"

// ERRCPP START

// The following code was autogenerated - see the utils/ directory
// E0000 - unexpected-char
// | The lexer found an unexpected character that could not begin
// | a token.
void E0000(Token const &tok)
{
    Error(Error::MsgType::ERROR, tok, "E0000 (unexpected-char)")
        .underline(Error::Underline(tok, '^')
            .error("unexpected character")
        )
    ;
}
// E0001 - unterm-charlit
// | The lexer found an unterminated character literal. A common
// | cause of this is character literals that are more than one
// | character long.
void E0001(Token const &tok)
{
    Error(Error::MsgType::ERROR, tok, "E0001 (unterm-charlit)")
        .underline(Error::Underline(tok, '^')
            .error("unterminated character literal")
        )
    ;
}
// E0002 - unterm-strlit
// | The lexer found a newline in a string literal, thereby
// | making it unterminated. Newlines that need to appear inside
// | the string literal must be escaped by putting `\n`.
void E0002(Token const &tok)
{
    Error(Error::MsgType::ERROR, tok, "E0002 (unterm-strlit)")
        .underline(Error::Underline(tok, '^')
            .error("unterminated string literal")
        )
    ;
}
// E0003 - invalid-intlit-base
// | The lexer found an integer literal that has an invalid base.
void E0003(Token const &tok)
{
    Error(Error::MsgType::ERROR, tok, "E0003 (invalid-intlit-base)")
        .underline(Error::Underline(tok, '^')
            .error("invalid integer literal base")
        )
    ;
}
// E0004 - nondecimal-floatlit
// | The lexer found a non-decimal floating point literal.
void E0004(Token const &tok)
{
    Error(Error::MsgType::ERROR, tok, "E0004 (nondecimal-floatlit)")
        .underline(Error::Underline(tok, '^')
            .error("invalid integer literal base")
        )
    ;
}
// E0100 - invalid-syntax-while
// | The parser found invalid syntax, and has information about
// | what construct was being parsed when the error happened.
void E0100(std::string const &justparsed, std::string const &expected, std::string const &whileparsing, Token const &lookahead, Token const &last)
{
    Error(Error::MsgType::ERROR, last, "E0100 (invalid-syntax-while)")
        .underline(Error::Underline(last, '^')
            .error(concatMsg("expected ", expected, " after ", justparsed, ", but got ", stringifyTokenType(lookahead.type), " instead"))
        )
        .underline(Error::Underline(lookahead, '=')
            .note("unexpected token here")
        )
    ;
}
// E0101 - invalid-syntax
// | The parser found invalid syntax, and has conflicting
// | information about what construct was being parsed when the
// | error happened.
void E0101(std::string const &justparsed, std::string const &expected, Token const &lookahead, Token const &last)
{
    Error(Error::MsgType::ERROR, last, "E0101 (invalid-syntax)")
        .underline(Error::Underline(last, '^')
            .error(concatMsg("expected ", expected, " after ", justparsed, " of ", whileparsing, ", but got ", stringifyTokenType(lookahead.type), " instead"))
        )
        .underline(Error::Underline(lookahead, '=')
            .note("unexpected token here")
        )
    ;
}
// This code was autogenerated - see the utils/ directory

// ERRCPP END
