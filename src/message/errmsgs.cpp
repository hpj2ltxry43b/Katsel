#include "ir/instruction.h"
#include "ir/module.h"
#include "utils/format.h"
#include "message/errmsgs.h"
#include "errors.h"

// ERRCPP START
// The following code was autogenerated - see the utils/ directory
// E0000 - unexpected-char
// | The lexer found an unexpected character that could not begin
// | a token.
void E0000(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0000", "unexpected-char");
    e.underline(Underline(tok, '^')
        .error("unexpected character")
    );
    e.report();
}

// E0001 - unterm-charlit
// | The lexer found an unterminated character literal.
void E0001(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0001", "unterm-charlit");
    e.underline(Underline(tok, '^')
        .error("unterminated character literal")
    );
    e.report();
}

// E0002 - unterm-strlit
// | The lexer found a newline in a string literal, thereby
// | making it unterminated.
void E0002(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0002", "unterm-strlit");
    e.underline(Underline(tok, '^')
        .error("unterminated string literal")
    );
    e.report();
}

// E0003 - invalid-intlit-base
// | The lexer found an integer literal that has an invalid base.
void E0003(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0003", "invalid-intlit-base");
    e.underline(Underline(tok, '^')
        .error("invalid integer literal base")
    );
    e.report();
}

// E0004 - nondecimal-floatlit
// | The lexer found a non-decimal floating point literal.
void E0004(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0004", "nondecimal-floatlit");
    e.underline(Underline(tok, '^')
        .error("invalid integer literal base")
    );
    e.report();
}

// E0005 - invalid-char-floatlit
// | Invalid numeric character for floating point literal
void E0005(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0005", "invalid-char-floatlit");
    e.underline(Underline(tok, '^')
        .error("invalid character in floating point literal")
    );
    e.report();
}

// E0006 - invalid-char-for-base
// | Invalid numberic character in integer literal for base
void E0006(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0006", "invalid-char-for-base");
    e.underline(Underline(tok, '^')
        .error("invalid character in integer literal for base")
    );
    e.report();
}

// E0007 - intlit-no-digits
// | Integer literal with no digits
void E0007(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0007", "intlit-no-digits");
    e.underline(Underline(tok, '^')
        .error("integer literal with no digits")
    );
    e.report();
}

// E0008 - multichar-charlit
// | Character literal with more than one character
void E0008(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0008", "multichar-charlit");
    e.underline(Underline(tok, '^')
        .error("character literal with more than one character")
    );
    e.report();
}

// E0009 - unterm-multiline-comment
// | Unterminated multiline comment
void E0009(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0009", "unterm-multiline-comment");
    e.underline(Underline(tok, '^')
        .error("unterminated multiline comment")
    );
    e.report();
}

// E0010 - dedent-nomatch
// | Dedent level does not match any other indentation level
void E0010(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0010", "dedent-nomatch");
    e.underline(Underline(tok, '^')
        .error("dedent to unknown level")
    );
    e.report();
}

// E0011 - char-after-backslash
// | Non-newline after line continuation backslash
void E0011(Token const &tok) {
    Error e = Error(MsgType::ERROR, tok, "syntax error", "E0011", "char-after-backslash");
    e.underline(Underline(tok, '^')
        .error("non-newline after line continuation backslash")
    );
    e.report();
}

// E0012 - unrecoverable-invalid-syntax
// | The parser found an unrecoverable syntax error.
void E0012(Token const &lookahead, Token const &lasttok, std::vector<std::string> const &expectations) {
    Error e = Error(MsgType::ERROR, lookahead, "syntax error", "E0012", "unrecoverable-invalid-syntax");
    e.underline(Underline(lookahead, '^')
        .error(format("unexpected %", lookahead.type))
    );
auto un (Underline(lasttok, '~'));
for (std::string const &expectation : expectations)
    un.hint(expectation);
e.underline(un);
    e.report();
}

// E0013 - simple-invalid-syntax
// | The parser found a syntax error and recovered by inserting,
// | substituting, or removing a single token.
void E0013(Token const &lookahead, Token const &lasttok, std::string const &bestfix, std::vector<std::string> const &expectations) {
    Error e = Error(MsgType::ERROR, lookahead, "syntax error", "E0013", "simple-invalid-syntax");
    e.underline(Underline(lookahead, '^')
        .error(format("unexpected %", lookahead.type))
        .note(bestfix)
    );
auto un (Underline(lasttok, '~'));
for (std::string const &expectation : expectations)
    un.hint(expectation);
e.underline(un);
    e.report();
}

// E0014 - panicking-invalid-syntax
// | The parser found a syntax error and recovered via panic mode
// | error recovery.
void E0014(Token const &lookahead, Token const &lasttok, Token const &panicuntil, std::vector<std::string> const &expectations) {
    Error e = Error(MsgType::ERROR, lookahead, "syntax error", "E0014", "panicking-invalid-syntax");
    e.underline(Underline(lookahead, '^')
        .error(format("unexpected %", lookahead.type))
    );
    e.underline(Underline(panicuntil, '-')
        .note(format("parser panicked until %", panicuntil.type))
    );
auto un (Underline(lasttok, '~'));
for (std::string const &expectation : expectations)
    un.hint(expectation);
e.underline(un);
    e.report();
}

// E0100 - lhs-unsupported-op
// | Left hand side of binary expression does not support
// | operator
void E0100(IR::ASTValue const &lhs, Token const &op) {
    Error e = Error(MsgType::ERROR, op, "type error", "E0100", "lhs-unsupported-op");
    e.underline(Underline(lhs, '^')
        .note(format("lhs is of type %", lhs.type()))
    );
    e.underline(Underline(op, '^')
        .error("unsupported binary operator for left operand")
    );
    e.report();
}

// E0101 - unary-unsupported-op
// | Operand of unary expression does not support operator
void E0101(IR::ASTValue const &operand, Token const &_operator) {
    Error e = Error(MsgType::ERROR, _operator, "type error", "E0101", "unary-unsupported-op");
    e.underline(Underline(operand, '^')
        .note(format("operand is of type %", operand.type()))
    );
    e.underline(Underline(_operator, '^')
        .error("unsupported unary operator")
    );
    e.report();
}

// E0102 - call-noncallable
// | Non-callable value called
void E0102(IR::ASTValue const &func, Token const &oparn) {
    Error e = Error(MsgType::ERROR, oparn, "type error", "E0102", "call-noncallable");
    e.underline(Underline(func, '^')
        .error("calling of non-callable value")
        .note(format("value of type %", func.type()))
    );
    e.report();
}

// E0103 - incorrect-arg
// | Incorrect argument to function call
void E0103(IR::ASTValue const &arg, IR::Type const *expected) {
    Error e = Error(MsgType::ERROR, arg, "type error", "E0103", "incorrect-arg");
    e.underline(Underline(arg, '^')
        .error("invalid argument to function call")
        .note(format("argument is of type %", arg.type()))
        .note(format("function expects %", expected))
    );
    e.report();
}

// E0104 - confl-tys-ifexpr
// | Conflicting types for branches of if expression
void E0104(IR::ASTValue const &truev, IR::ASTValue const &falsev, Token const &iftok, Token const &elsetok) {
    Error e = Error(MsgType::ERROR, iftok, "type error", "E0104", "confl-tys-ifexpr");
    e.underline(Underline(iftok, '^')
        .error("conflicting types for branches of if expression")
    );
    e.underline(Underline(elsetok, '-')
    );
    e.underline(Underline(truev, '~')
        .note(format("%", truev.type()))
    );
    e.underline(Underline(falsev, '~')
        .note(format("%", falsev.type()))
    );
    e.report();
}

// E0105 - assign-conflict-tys
// | Assignment target and value do not have same type
void E0105(IR::ASTValue const &lhs, IR::ASTValue const &rhs, Token const &eq) {
    Error e = Error(MsgType::ERROR, eq, "type error", "E0105", "assign-conflict-tys");
    e.underline(Underline(eq, '^')
        .error("conflicting types for assignment")
    );
    e.underline(Underline(lhs, '~')
        .note(format("%", lhs.type()))
    );
    e.underline(Underline(rhs, '~')
        .note(format("%", rhs.type()))
    );
    e.report();
}

// E0106 - conflict-ret-ty
// | Conflicting return types
void E0106(IR::ASTValue const &val, IR::Function *f) {
    Error e = Error(MsgType::ERROR, val, "type error", "E0106", "conflict-ret-ty");
    e.underline(Underline(val, '^')
        .error("conflicting return type")
        .note(format("returning %", val.type()))
    );
    e.underline(Underline(f->defAST()->retty.get(), '~')
        .note(format("function returns %", f->ty->ret))
    );
    e.report();
}

// E0107 - no-deref
// | Cannot dereference non-pointer
void E0107(Token const &op, IR::ASTValue const &val) {
    Error e = Error(MsgType::ERROR, val, "type error", "E0107", "no-deref");
    e.underline(Underline(op, '^')
        .error(format("dereferencing of non-pointer type %", val.type()))
    );
    e.underline(Underline(val, '~')
    );
    e.report();
}

// E0108 - conflict-var-init-ty
// | Conflicting type for variable initialization
void E0108(Token const &eq, Token const &name, ASTNS::Type *typeAST, IR::ASTValue const &init, IR::Type const *expectedType) {
    Error e = Error(MsgType::ERROR, eq, "type error", "E0108", "conflict-var-init-ty");
    e.underline(Underline(eq, '~')
    );
    e.underline(Underline(name, '~')
    );
    e.underline(Underline(init, '^')
        .error("conflicting types for variable initialization")
        .note(format("%", init.type()))
    );
    e.underline(Underline(typeAST, '~')
        .note(format("%", expectedType))
    );
    e.report();
}

// E0109 - invalid-cast
// | Invalid cast
void E0109(ASTNS::AST *ast, IR::ASTValue v, IR::Type const *newty) {
    Error e = Error(MsgType::ERROR, ast, "type error", "E0109", "invalid-cast");
    e.underline(Underline(ast, '^')
        .error(format("invalid cast from % to %", v.type(), newty))
    );
    e.report();
}

// E0110 - conflict-tys-binary-op
// | Conflicting types to binary operator
void E0110(IR::ASTValue const &lhs, IR::ASTValue const &rhs, Token const &op) {
    Error e = Error(MsgType::ERROR, op, "type error", "E0110", "conflict-tys-binary-op");
    e.underline(Underline(lhs, '~')
        .note(format("%", lhs.type()))
    );
    e.underline(Underline(rhs, '~')
        .note(format("%", rhs.type()))
    );
    e.underline(Underline(op, '^')
        .error("conflicting types to binary operator")
    );
    e.report();
}

// E0111 - cond-not-bool
// | Using a non-bool value as a condition
void E0111(IR::ASTValue &v) {
    Error e = Error(MsgType::ERROR, v, "type error", "E0111", "cond-not-bool");
    e.underline(Underline(v, '^')
        .error(format("usage of % as condition", v.type()))
    );
    e.report();
}

// E0112 - ptr-arith-rhs-not-num
// | Cannot do pointer arithmetic with non-integer as right-hand-
// | side of expression
void E0112(IR::ASTValue const &lhs, Token const &optok, IR::ASTValue const &rhs) {
    Error e = Error(MsgType::ERROR, optok, "type error", "E0112", "ptr-arith-rhs-not-num");
    e.underline(Underline(lhs, '~')
    );
    e.underline(Underline(rhs, '~')
        .note(format("%", rhs.type()))
    );
    e.underline(Underline(optok, '^')
        .error("pointer arithmetic requires an integral right-hand operand")
    );
    e.report();
}

// E0113 - no-else-not-void
// | If expression with non-void true expression and no else case
void E0113(IR::ASTValue const &truev, Token const &iftok) {
    Error e = Error(MsgType::ERROR, iftok, "type error", "E0113", "no-else-not-void");
    e.underline(Underline(iftok, '^')
        .error("if expression with non-void true expression and no else case")
    );
    e.underline(Underline(truev, '~')
        .note(format("%", truev.type()))
    );
    e.report();
}

// E0114 - typeless-this
// | 'this' parameter used outside of impl or class block
void E0114(ASTNS::ThisParam *p) {
    Error e = Error(MsgType::ERROR, p, "type error", "E0114", "typeless-this");
    e.underline(Underline(p, '^')
        .error("'this' parameter not allowed outside of impl or class block")
    );
    e.report();
}

// E0115 - wrong-num-args
// | Wrong number of arguments to function call
void E0115(IR::ASTValue const &func, Token const &oparn, std::vector<IR::ASTValue> const &args) {
    Error e = Error(MsgType::ERROR, oparn, "type error", "E0115", "wrong-num-args");
    e.underline(Underline(oparn, '^')
        .error("wrong number of arguments to function call")
    );
    e.underline(Underline(func, '~')
    );
    e.underline(Underline(static_cast<IR::Function*>(func.val)->defAST(), '~')
        .note(format("function expects % arguments, but got % arguments", static_cast<IR::FunctionType*>(func.type())->paramtys.size(), args.size()))
    );
    e.report();
}

// E0200 - redecl-sym
// | Symbol was redeclared
void E0200(Token const &name, IR::Value *val) {
    Error e = Error(MsgType::ERROR, name, "name error", "E0200", "redecl-sym");
    e.underline(Underline(name, '^')
        .error("redeclaration of symbol")
    );
    if (IR::DeclaredValue *asDeclared = dynamic_cast<IR::DeclaredValue*>(val)) {
        if (!dynamic_cast<ASTNS::ImplicitDecl*>(asDeclared->defAST())) {
            e.underline(Underline(asDeclared->defAST(), '~')
                .note("previous declaration"));
       }
    }
    e.report();
}

// E0201 - undecl-symb
// | Usage of undeclared symbol
void E0201(Location const &path) {
    Error e = Error(MsgType::ERROR, path, "name error", "E0201", "undecl-symb");
    e.underline(Underline(path, '^')
        .error("undeclared symbol")
    );
    e.report();
}

// E0202 - redecl-param
// | Redeclaraion of parameter in function declaration
void E0202(ASTNS::ParamB *param, IR::Instrs::Register const *prev) {
    Error e = Error(MsgType::ERROR, param, "name error", "E0202", "redecl-param");
    e.underline(Underline(param, '^')
        .error("redeclaration of parameter")
    );
    e.underline(Underline(prev->defAST(), '~')
        .note("previous declaration")
    );
    e.report();
}

// E0203 - redecl-var
// | Redeclaration of variable
void E0203(Token const &name, IR::Instrs::Register const *prev) {
    Error e = Error(MsgType::ERROR, name, "name error", "E0203", "redecl-var");
    e.underline(Underline(name, '^')
        .error("redeclaration of variable")
    );
    e.underline(Underline(prev->defAST(), '~')
        .note("previous declaration")
    );
    e.report();
}

// E0204 - not-a-type
// | Expected a type but path resolved to something else
void E0204(Location const &notty, ASTNS::AST *declAST) {
    Error e = Error(MsgType::ERROR, notty, "name error", "E0204", "not-a-type");
    e.underline(Underline(notty, '^')
        .error("not a type")
    );
    e.underline(Underline(declAST, '~')
        .note("declared here")
    );
    e.report();
}

// E0205 - no-member-in
// | No member of a certain name within another member
void E0205(IR::DeclSymbol const *prev, Token const &current) {
    Error e = Error(MsgType::ERROR, current, "name error", "E0205", "no-member-in");
    e.underline(Underline(current, '^')
        .error(format("no member called % in %", current, prev))
    );
    e.report();
}

// E0206 - no-this
// | usage of 'this' outside method
void E0206(Token const &th) {
    Error e = Error(MsgType::ERROR, th, "name error", "E0206", "no-this");
    e.underline(Underline(th, '^')
        .error(format("usage of % outside method", th))
    );
    e.report();
}

// E0300 - addrof-not-lvalue
// | Taking an address of a non-lvalue is impossible
void E0300(Token const &op, IR::ASTValue const &val) {
    Error e = Error(MsgType::ERROR, val, "value error", "E0300", "addrof-not-lvalue");
    e.underline(Underline(op, '^')
        .error("taking address of non-lvalue")
    );
    e.underline(Underline(val, '~')
    );
    e.report();
}

// E0301 - assign-invalid-lhs
// | Invalid assignment target
void E0301(Token const &eq, IR::ASTValue const &lhs) {
    Error e = Error(MsgType::ERROR, eq, "value error", "E0301", "assign-invalid-lhs");
    e.underline(Underline(eq, '^')
        .error("non-lvalue assignment")
    );
    e.underline(Underline(lhs, '~')
    );
    e.report();
}

// E0302 - assign-not-mut
// | Cannot assign to non-mutable lvalue
void E0302(IR::ASTValue const &v, Token const &eq, IR::Instrs::DerefPtr *targetDeref) {
    Error e = Error(MsgType::ERROR, v, "value error", "E0302", "assign-not-mut");
    e.underline(Underline(eq, '^')
        .error("cannot assign to immutable lvalue")
    );
    e.underline(Underline(v, '~')
    );
    if (IR::DeclaredValue *asDeclared = dynamic_cast<IR::DeclaredValue*>(targetDeref->ptr.val)) {
        if (!dynamic_cast<ASTNS::ImplicitDecl*>(asDeclared->defAST())) {
            e.underline(Underline(asDeclared->defAST(), '~')
                .note("variable declared immutable here"));
       }
    }
    e.report();
}

// E0303 - mut-addrof-nonmut-op
// | Cannot take a mutable pointer to non-mutable lvalue
void E0303(Token const &op, IR::Instrs::DerefPtr *asDeref) {
    Error e = Error(MsgType::ERROR, op, "value error", "E0303", "mut-addrof-nonmut-op");
    e.underline(Underline(op, '^')
        .error("cannot take mutable pointer to non-mutable lvalue")
    );
    if (IR::DeclaredValue *asDeclared = dynamic_cast<IR::DeclaredValue*>(asDeref->ptr.val)) {
        if (!dynamic_cast<ASTNS::ImplicitDecl*>(asDeclared->defAST())) {
            e.underline(Underline(asDeclared->defAST(), '~')
                .note("value declared immutable here"));
       }
    }
    e.report();
}

// E0400 - no-suppress
// | Cannot suppress an expression that is not the implicit
// | return value of a block
void E0400(Location const &dot) {
    Error e = Error(MsgType::ERROR, dot, "miscellaneous error", "E0400", "no-suppress");
    e.underline(Underline(dot, '^')
        .error("implicit return suppression not allowed here")
    );
    e.report();
}

// E0401 - this-not-first
// | 'this' parameter is not the first parameter of a method
void E0401(ASTNS::ThisParam *ast) {
    Error e = Error(MsgType::ERROR, ast, "miscellaneous error", "E0401", "this-not-first");
    e.underline(Underline(ast, '^')
        .error("'this' parameter must be the first parameter of a method")
    );
    e.report();
}

// W0000 - Wextra-semi
// | Extra semicolon
void W0000(Token const &semi) {
    Error e = Error(MsgType::WARNING, semi, "code style", "W0000", "Wextra-semi");
    e.underline(Underline(semi, '^')
        .warning("unnecessary semicolon")
    );
    e.report();
}

// This code was autogenerated - see the utils/ directory
// ERRCPP END
