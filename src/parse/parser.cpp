#include "parse/parser.h"

#include "lex/tokentype.h"
#include "message/errors.h"

#include <sstream>
#include <stack>

Parser::Parser(Lexer &l, File &sourcefile): lexer(l), sourcefile(sourcefile) {}

std::unique_ptr<ASTNS::AST> Parser::parse()
{
    struct stackitem
    {
        int state;
        stackitem(size_t state): state(state) {}
    };

    struct tokstackitem : public stackitem
    {
        Token tok;
        tokstackitem(size_t state, Token tok): stackitem(state), tok(tok) {}
    };
    
    struct aststackitem : public stackitem
    {
        std::unique_ptr<ASTNS::AST> ast;
        aststackitem(size_t state, std::unique_ptr<ASTNS::AST> ast): stackitem(state), ast(std::move(ast)) {}
    };

    // parser loop {{{
    // PARSERLOOP START

// The following code was autogenerated - see the utils/ directory
    bool done = false;
    Token lookahead (consume());
    std::stack<std::unique_ptr<stackitem>> stack;
    stack.push(std::make_unique<stackitem>(0));
    while (true)
    {
        switch (stack.top()->state)
        {
            case 0:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::DECINTLIT:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::OPARN:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 1:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            done = true;
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 2:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::stmt>(a0);
                            size_t newstate = getGoto<ASTNS::stmt>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 3:
               switch (lookahead.type)
               {
                    case TokenType::PLUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::expr>(a0);
                            size_t newstate = getGoto<ASTNS::expr>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::expr>(a0);
                            size_t newstate = getGoto<ASTNS::expr>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 4:
               switch (lookahead.type)
               {
                    case TokenType::STAR:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 5:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 6:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 7:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 8:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 9:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 10:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::DECINTLIT:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::OPARN:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 11:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::DECINTLIT:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::OPARN:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 12:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::DECINTLIT:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::OPARN:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 13:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::DECINTLIT:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::OPARN:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 14:
               switch (lookahead.type)
               {
                    case TokenType::MINUS:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::TILDE:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::DECINTLIT:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::OPARN:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 15:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 16:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::unary>(a0, a1);
                            size_t newstate = getGoto<ASTNS::unary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 17:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 18:
               switch (lookahead.type)
               {
                    case TokenType::STAR:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 19:
               switch (lookahead.type)
               {
                    case TokenType::STAR:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            Token last (lookahead);
                            stack.push(std:make_unique<tokstackitem>(last))
                            lookahead = consume();
                        }
                        break;
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::add>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::add>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 20:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 21:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            aststackitem *asi2 = dynamic_cast<aststackitem*>(_a2.get());
                            std::unique_ptr<ASTNS::AST> a2 (asi2->ast);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            tokstackitem *tsi1 = dynamic_cast<tokstackitem*>(_a1.get());
                            Token a1 (tsi1->tok);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            aststackitem *asi0 = dynamic_cast<aststackitem*>(_a0.get());
                            std::unique_ptr<ASTNS::AST> a0 (asi0->ast);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::mult>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::mult>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            case 22:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            tokstackitem *tsi2 = dynamic_cast<tokstackitem*>(_a2.get());
                            Token a2 (tsi2->tok);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::CPARN:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            tokstackitem *tsi2 = dynamic_cast<tokstackitem*>(_a2.get());
                            Token a2 (tsi2->tok);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::PLUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            tokstackitem *tsi2 = dynamic_cast<tokstackitem*>(_a2.get());
                            Token a2 (tsi2->tok);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::MINUS:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            tokstackitem *tsi2 = dynamic_cast<tokstackitem*>(_a2.get());
                            Token a2 (tsi2->tok);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::STAR:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            tokstackitem *tsi2 = dynamic_cast<tokstackitem*>(_a2.get());
                            Token a2 (tsi2->tok);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    case TokenType::SLASH:
                        {
                            std::unique_ptr<stackitem> _a2 = stack.pop();
                            tokstackitem *tsi2 = dynamic_cast<tokstackitem*>(_a2.get());
                            Token a2 (tsi2->tok);
                            std::unique_ptr<stackitem> _a1 = stack.pop();
                            aststackitem *asi1 = dynamic_cast<aststackitem*>(_a1.get());
                            std::unique_ptr<ASTNS::AST> a1 (asi1->ast);
                            std::unique_ptr<stackitem> _a0 = stack.pop();
                            tokstackitem *tsi0 = dynamic_cast<tokstackitem*>(_a0.get());
                            Token a0 (tsi0->tok);
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::primary>(a0, a1, a2);
                            size_t newstate = getGoto<ASTNS::primary>(stack.top().state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    default:
                        Error(Error::MsgType::ERROR, lookahead, "Invalid syntax")
                            .primary(Error::Primary(lookahead)
                                 .error("Invalid syntax"))
                             .report();
                        break;
                }
                break;
            default:
                Error(Error::MsgType::INTERR, lookahead, "Parser reached invalid state")
                    .primary(Error::Primary(lookahead)
                        .error(static_cast<std::stringstream&>(std::stringstream() << "Parser reached invalid state: " << state).str()))
                    .reportAbort();
        }
    }
// This code was autogenerated - see the utils/ directory

    // PARSERLOOP END
    // }}}
}

Token Parser::consume()
{
    Token cur;
    while (true)
    {
        cur = lexer.nextToken();
        if (cur.type != TokenType::ERROR) return cur;

        Error(Error::MsgType::ERROR, cur, cur.message)
            .primary(Error::Primary(cur)
                .error(cur.message))
            .report();
    }

    return cur;
}

// get goto {{{
// GETGOTO START

// The following code was autogenerated - see the utils/ directory
template <> size_t Parser::getGoto<ASTNS::stmt>(size_t state)
{
    switch (stack.top()->state)
    {
        case 0:
             return 1;
        default:
            reportAbortNoh("retrieve goto of nonterminal stmt in state 22");
    }
}
template <> size_t Parser::getGoto<ASTNS::expr>(size_t state)
{
    switch (stack.top()->state)
    {
        case 0:
             return 2;
        case 10:
             return 17;
        default:
            reportAbortNoh("retrieve goto of nonterminal expr in state 22");
    }
}
template <> size_t Parser::getGoto<ASTNS::add>(size_t state)
{
    switch (stack.top()->state)
    {
        case 0:
             return 3;
        case 10:
             return 3;
        default:
            reportAbortNoh("retrieve goto of nonterminal add in state 22");
    }
}
template <> size_t Parser::getGoto<ASTNS::mult>(size_t state)
{
    switch (stack.top()->state)
    {
        case 0:
             return 4;
        case 10:
             return 4;
        case 11:
             return 18;
        case 12:
             return 19;
        default:
            reportAbortNoh("retrieve goto of nonterminal mult in state 22");
    }
}
template <> size_t Parser::getGoto<ASTNS::unary>(size_t state)
{
    switch (stack.top()->state)
    {
        case 0:
             return 5;
        case 6:
             return 15;
        case 7:
             return 16;
        case 10:
             return 5;
        case 11:
             return 5;
        case 12:
             return 5;
        case 13:
             return 20;
        case 14:
             return 21;
        default:
            reportAbortNoh("retrieve goto of nonterminal unary in state 22");
    }
}
template <> size_t Parser::getGoto<ASTNS::primary>(size_t state)
{
    switch (stack.top()->state)
    {
        case 0:
             return 8;
        case 6:
             return 8;
        case 7:
             return 8;
        case 10:
             return 8;
        case 11:
             return 8;
        case 12:
             return 8;
        case 13:
             return 8;
        case 14:
             return 8;
        default:
            reportAbortNoh("retrieve goto of nonterminal primary in state 22");
    }
}
template <> size_t Parser::getGoto<ASTNS::augment>(size_t state)
{
    switch (stack.top()->state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal augment in state 22");
    }
}
// This code was autogenerated - see the utils/ directory

// GETGOTO END
// }}}
