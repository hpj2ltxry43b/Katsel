#include "parse/parser.h"

#include "lex/tokentype.h"
#include "message/errors.h"

#include <sstream>
#include <stack>

Parser::Parser(Lexer &l, File &sourcefile): lexer(l), sourcefile(sourcefile) {}

// get goto {{{
// GETGOTO START

// The following code was autogenerated - see the utils/ directory
template <> size_t Parser::getGoto<ASTNS::Declarations>(size_t state)
{
    switch (state)
    {
        case 0:
             return 1;
        default:
            reportAbortNoh("retrieve goto of nonterminal declarations in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Decl>(size_t state)
{
    switch (state)
    {
        case 0:
             return 2;
        case 1:
             return 18;
        default:
            reportAbortNoh("retrieve goto of nonterminal decl in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Function>(size_t state)
{
    switch (state)
    {
        case 0:
             return 3;
        case 1:
             return 3;
        default:
            reportAbortNoh("retrieve goto of nonterminal function in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Type>(size_t state)
{
    switch (state)
    {
        case 0:
             return 4;
        case 1:
             return 4;
        default:
            reportAbortNoh("retrieve goto of nonterminal type in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Block>(size_t state)
{
    switch (state)
    {
        case 21:
             return 25;
        case 27:
             return 31;
        default:
            reportAbortNoh("retrieve goto of nonterminal block in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Paramlist>(size_t state)
{
    switch (state)
    {
        case 20:
             return 22;
        default:
            reportAbortNoh("retrieve goto of nonterminal paramlist in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Stmts>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal stmts in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Stmt>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal stmt in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Varstmt>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal varstmt in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Exprstmt>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal exprstmt in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Retstmt>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal retstmt in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Varstmtfinisher>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal varstmtfinisher in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Expression>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal expression in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Args>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal args in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Assignmentexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal assignmentexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Ternaryexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal ternaryexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Binorexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal binorexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Binandexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal binandexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Binnotexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal binnotexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Compeqexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal compeqexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Complgtexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal complgtexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Bitxorexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal bitxorexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Bitorexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal bitorexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Bitandexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal bitandexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Bitshiftexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal bitshiftexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Additionexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal additionexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Multexpr>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal multexpr in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Unary>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal unary in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Call>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal call in state 34");
    }
}
template <> size_t Parser::getGoto<ASTNS::Primary>(size_t state)
{
    switch (state)
    {
        default:
            reportAbortNoh("retrieve goto of nonterminal primary in state 34");
    }
}
// This code was autogenerated - see the utils/ directory

// GETGOTO END
// }}}

std::unique_ptr<ASTNS::AST> Parser::parse()
{
    struct stackitem
    {
        int state;
        stackitem(size_t state): state(state) {}
        virtual void dummy() {}
    };

    struct tokstackitem : public stackitem
    {
        Token tok;
        tokstackitem(size_t state, Token tok): stackitem(state), tok(tok) {}
    };
    
    struct aststackitem : public stackitem
    {
        std::unique_ptr<ASTNS::AST> ast;
        aststackitem(size_t state, std::unique_ptr<ASTNS::AST> ast): stackitem(state), ast(std::move(ast)) {}
    };

    // parser loop {{{
    // PARSERLOOP START

// The following code was autogenerated - see the utils/ directory
#define SHIFT(newstate) \
    lasttok = lookahead;\
    stack.push(std::make_unique<tokstackitem>(newstate, lasttok));\
    lookahead = consume();
#define REDUCET(n) \
    std::unique_ptr<stackitem> _a ## n = std::move(stack.top()); stack.pop();\
    tokstackitem *si ## n = dynamic_cast<tokstackitem*>(_a ## n .get());\
    Token a ## n (si ## n ->tok);
#define REDUCEA(n) \
    std::unique_ptr<stackitem> _a ## n = std::move(stack.top()); stack.pop();\
    aststackitem *si ## n = dynamic_cast<aststackitem*>(_a ## n .get());\
    std::unique_ptr<ASTNS::AST> a ## n (std::move(si ## n ->ast));
#define SHIFTON(ty, n) \
    case ty: \
        {SHIFT(n)} break;
#define DEFAULTINVALID2(justparsed, expected) \
    default: \
        invalidSyntax(justparsed, expected, lookahead, lasttok);\
        done = true;\
        break;
#define DEFAULTINVALID3(justparsed, expected, whileparsing) \
    default: \
        invalidSyntax(justparsed, expected, whileparsing, lookahead, lasttok);\
        done = true;\
        break;
#define REDUCESKIP(cl) \
    {\
        std::unique_ptr<stackitem> popped (std::move(stack.top())); stack.pop();\
        aststackitem *asi = dynamic_cast<aststackitem*>(popped.get());\
        size_t newstate = getGoto<ASTNS::cl>(stack.top()->state);\
        stack.push(std::make_unique<aststackitem>(newstate, std::move(asi->ast)));\
    }
    bool done = false;
    Token lookahead (consume());
    Token lasttok = lookahead;
    std::stack<std::unique_ptr<stackitem>> stack;
    stack.push(std::make_unique<stackitem>(0));
    while (!done)
    {
        switch (stack.top()->state)
        {
            case 0:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::BOOL, 14)
                    SHIFTON(TokenType::CHAR, 17)
                    SHIFTON(TokenType::DOUBLE, 15)
                    SHIFTON(TokenType::FLOAT, 13)
                    SHIFTON(TokenType::SINT16, 10)
                    SHIFTON(TokenType::SINT32, 11)
                    SHIFTON(TokenType::SINT64, 12)
                    SHIFTON(TokenType::SINT8, 9)
                    SHIFTON(TokenType::UINT16, 6)
                    SHIFTON(TokenType::UINT32, 7)
                    SHIFTON(TokenType::UINT64, 8)
                    SHIFTON(TokenType::UINT8, 5)
                    SHIFTON(TokenType::VOID, 16)
                    DEFAULTINVALID3("beginning", "declaration list", "compilation unit")
                }
                break;
            case 1:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::BOOL, 14)
                    SHIFTON(TokenType::EOF_, 14)
                    SHIFTON(TokenType::CHAR, 17)
                    SHIFTON(TokenType::DOUBLE, 15)
                    SHIFTON(TokenType::FLOAT, 13)
                    SHIFTON(TokenType::SINT16, 10)
                    SHIFTON(TokenType::SINT32, 11)
                    SHIFTON(TokenType::SINT64, 12)
                    SHIFTON(TokenType::SINT8, 9)
                    SHIFTON(TokenType::UINT16, 6)
                    SHIFTON(TokenType::UINT32, 7)
                    SHIFTON(TokenType::UINT64, 8)
                    SHIFTON(TokenType::UINT8, 5)
                    SHIFTON(TokenType::VOID, 16)
                    DEFAULTINVALID2("declaration list", "declaration")
                }
                break;
            case 2:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                    case TokenType::CHAR:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FLOAT:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VOID:
                        REDUCESKIP(Declarations);
                        break;
                    DEFAULTINVALID3("declaration", "nothing", "declaration list")
                }
                break;
            case 3:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                    case TokenType::CHAR:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FLOAT:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VOID:
                        REDUCESKIP(Decl);
                        break;
                    DEFAULTINVALID3("function declaration", "nothing", "declaration")
                }
                break;
            case 4:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::IDENTIFIER, 19)
                    DEFAULTINVALID3("type specifier", "TokenType::IDENTIFIER", "function declaration")
                }
                break;
            case 5:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::UINT8", "nothing", "type specifier")
                }
                break;
            case 6:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::UINT16", "nothing", "type specifier")
                }
                break;
            case 7:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::UINT32", "nothing", "type specifier")
                }
                break;
            case 8:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::UINT64", "nothing", "type specifier")
                }
                break;
            case 9:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::SINT8", "nothing", "type specifier")
                }
                break;
            case 10:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::SINT16", "nothing", "type specifier")
                }
                break;
            case 11:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::SINT32", "nothing", "type specifier")
                }
                break;
            case 12:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::SINT64", "nothing", "type specifier")
                }
                break;
            case 13:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::FLOAT", "nothing", "type specifier")
                }
                break;
            case 14:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::BOOL", "nothing", "type specifier")
                }
                break;
            case 15:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::DOUBLE", "nothing", "type specifier")
                }
                break;
            case 16:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::VOID", "nothing", "type specifier")
                }
                break;
            case 17:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        {
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Type>(std::move(a0));
                            size_t newstate = getGoto<ASTNS::Type>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::CHAR", "nothing", "type specifier")
                }
                break;
            case 18:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                    case TokenType::CHAR:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FLOAT:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VOID:
                        {
                            REDUCEA(1)
                            REDUCEA(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Declarations>(std::move(a0), std::move(a1));
                            size_t newstate = getGoto<ASTNS::Declarations>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("declaration", "nothing", "declaration list")
                }
                break;
            case 19:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::OPARN, 20)
                    DEFAULTINVALID3("TokenType::IDENTIFIER", "TokenType::OPARN", "function declaration")
                }
                break;
            case 20:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::CPARN, 21)
                    SHIFTON(TokenType::paramlist, 23)
                    SHIFTON(TokenType::type, 24)
                    DEFAULTINVALID3("TokenType::OPARN", "either TokenType::CPARN or parameter list", "function declaration")
                }
                break;
            case 21:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::OCURB, 26)
                    DEFAULTINVALID3("TokenType::CPARN", "code block", "function declaration")
                }
                break;
            case 22:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::CPARN, 27)
                    DEFAULTINVALID3("parameter list", "TokenType::CPARN", "function declaration")
                }
                break;
            case 23:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::COMMA, 28)
                    DEFAULTINVALID3("TokenType::paramlist", "TokenType::COMMA", "parameter list")
                }
                break;
            case 24:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::IDENTIFIER, 29)
                    DEFAULTINVALID3("TokenType::type", "TokenType::IDENTIFIER", "parameter list")
                }
                break;
            case 25:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                    case TokenType::CHAR:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FLOAT:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VOID:
                        {
                            REDUCEA(4)
                            REDUCET(3)
                            REDUCET(2)
                            REDUCET(1)
                            REDUCEA(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Function>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4));
                            size_t newstate = getGoto<ASTNS::Function>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("code block", "nothing", "function declaration")
                }
                break;
            case 26:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::stmts, 30)
                    DEFAULTINVALID3("TokenType::OCURB", "TokenType::stmts", "code block")
                }
                break;
            case 27:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::OCURB, 26)
                    DEFAULTINVALID3("TokenType::CPARN", "code block", "function declaration")
                }
                break;
            case 28:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::type, 32)
                    DEFAULTINVALID3("TokenType::COMMA", "TokenType::type", "parameter list")
                }
                break;
            case 29:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        {
                            REDUCET(1)
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Paramlist>(std::move(a0), std::move(a1));
                            size_t newstate = getGoto<ASTNS::Paramlist>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::IDENTIFIER", "nothing", "parameter list")
                }
                break;
            case 30:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::CCURB, 33)
                    DEFAULTINVALID3("TokenType::stmts", "TokenType::CCURB", "code block")
                }
                break;
            case 31:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                    case TokenType::CHAR:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FLOAT:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VOID:
                        {
                            REDUCEA(5)
                            REDUCET(4)
                            REDUCEA(3)
                            REDUCET(2)
                            REDUCET(1)
                            REDUCEA(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Function>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4), std::move(a5));
                            size_t newstate = getGoto<ASTNS::Function>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("code block", "nothing", "function declaration")
                }
                break;
            case 32:
               switch (lookahead.type)
               {
                    SHIFTON(TokenType::IDENTIFIER, 34)
                    DEFAULTINVALID3("TokenType::type", "TokenType::IDENTIFIER", "parameter list")
                }
                break;
            case 33:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                    case TokenType::CHAR:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FLOAT:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VOID:
                        {
                            REDUCET(2)
                            REDUCET(1)
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Block>(std::move(a0), std::move(a1), std::move(a2));
                            size_t newstate = getGoto<ASTNS::Block>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::CCURB", "nothing", "code block")
                }
                break;
            case 34:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        {
                            REDUCET(3)
                            REDUCET(2)
                            REDUCET(1)
                            REDUCET(0)
                            std::unique_ptr<ASTNS::AST> push = std::make_unique<ASTNS::Paramlist>(std::move(a0), std::move(a1), std::move(a2), std::move(a3));
                            size_t newstate = getGoto<ASTNS::Paramlist>(stack.top()->state);
                            stack.push(std::make_unique<aststackitem>(newstate, std::move(push)));
                        }
                        break;
                    DEFAULTINVALID3("TokenType::IDENTIFIER", "nothing", "parameter list")
                }
                break;
            default:
                Error(Error::MsgType::INTERR, lookahead, "Parser reached invalid state")
                    .primary(Error::Primary(lookahead)
                        .error(static_cast<std::stringstream&>(std::stringstream() << "Parser reached invalid state: " << stack.top()->state).str()))
                    .reportAbort();
        }
    }
#undef SHIFT
#undef REDUCET
#undef REDUCEA
#undef REDUCESKIP
#undef SHIFTON
#undef DEFAULTINVALID2
#undef DEFAULTINVALID3
// This code was autogenerated - see the utils/ directory

    // PARSERLOOP END
    // }}}

    aststackitem *asir (dynamic_cast<aststackitem*>(stack.top().get()));
    if (!asir)
        return nullptr;

    return std::move(asir->ast);
}

Token Parser::consume()
{
    Token cur;
    while (true)
    {
        cur = lexer.nextToken();
        if (cur.type != TokenType::ERROR) return cur;

        Error(Error::MsgType::ERROR, cur, cur.message)
            .primary(Error::Primary(cur)
                .error(cur.message))
            .report();
    }

    return cur;
}

void Parser::invalidSyntax(const char *justparsed, const char *expected, const char *whileparsing, Token const &lookahead, Token const &last)
{
    std::stringstream ssl;
    std::stringstream sss;
    ssl << "expected " << expected << " after " << justparsed << " of " << whileparsing << ", but got " << stringifyTokenType(lookahead.type) << " instead";
    sss << "expected " << expected;
    Error(Error::MsgType::ERROR, lookahead, ssl.str())
        .primary(Error::Primary(last)
            .error(sss.str()))
        .primary(Error::Primary(lookahead)
            .note("unexpected token here"))
        .report();
}
void Parser::invalidSyntax(const char *justparsed, const char *expected, Token const &lookahead, Token const &last)
{
    std::stringstream ssl;
    std::stringstream sss;
    ssl << "expected " << expected << " after " << justparsed << ", but got " << stringifyTokenType(lookahead.type) << " instead";
    sss << "expected " << expected;
    Error(Error::MsgType::ERROR, lookahead, ssl.str())
        .primary(Error::Primary(last)
            .error(sss.str()))
        .primary(Error::Primary(lookahead)
            .note("unexpected token here"))
        .report();
}
