#include "parse/parser.h"
#include "parsestack.h" // in a private header file
#include <vector>
#include <iostream>
#include "utils/format.h"
#include "utils/assert.h"
#include "message/errmsgs.h"

// get goto {{{
// GETGOTO START
// The following code was autogenerated - see the utils/ directory
size_t getGoto(NonTerminal nterm, size_t state) {
    switch (nterm) {
        case NonTerminal::augment:
            switch (state) {
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::CU:
            switch (state) {
                case 0: 
                    return 1;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::AnotherParam:
            switch (state) {
                case 40: 
                    return 44;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Param:
            switch (state) {
                case 28: 
                    return 36;
                case 40: 
                    return 45;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ParamSegment:
            switch (state) {
                case 28: 
                    return 35;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ParamList:
            switch (state) {
                case 28: 
                    return 34;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::AnotherArg:
            switch (state) {
                case 204: 
                    return 210;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Arg:
            switch (state) {
                case 152: 
                    return 189;
                case 204: 
                    return 211;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ArgSegment:
            switch (state) {
                case 152: 
                    return 188;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ArgList:
            switch (state) {
                case 152: 
                    return 187;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::AnotherVarStmtItem:
            switch (state) {
                case 160: 
                    return 196;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::VarStmtItem:
            switch (state) {
                case 63: 
                    return 115;
                case 160: 
                    return 197;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::VarStmtItemSegment:
            switch (state) {
                case 63: 
                    return 114;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::VarStmtItemList:
            switch (state) {
                case 63: 
                    return 113;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::AnotherStmt:
            switch (state) {
                case 58: 
                    return 111;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Stmt:
            switch (state) {
                case 52: case 55: case 57: case 110: 
                    return 59;
                case 58: 
                    return 112;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::StmtList:
            switch (state) {
                case 52: case 55: case 57: case 110: 
                    return 58;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::AnotherDecl:
            switch (state) {
                case 2: 
                    return 8;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Decl:
            switch (state) {
                case 0: 
                    return 3;
                case 2: 
                    return 9;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::DeclList:
            switch (state) {
                case 0: 
                    return 2;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ParamList_OPT:
            switch (state) {
                case 28: 
                    return 33;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ArgList_OPT:
            switch (state) {
                case 152: 
                    return 186;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::StmtList_OPT:
            switch (state) {
                case 52: 
                    return 56;
                case 55: 
                    return 105;
                case 57: 
                    return 109;
                case 110: 
                    return 158;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ImplRet_OPT:
            switch (state) {
                case 56: 
                    return 106;
                case 105: 
                    return 154;
                case 109: 
                    return 157;
                case 158: 
                    return 195;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ImplRet:
            switch (state) {
                case 56: case 105: case 109: case 158: 
                    return 107;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Expr_OPT:
            switch (state) {
                case 167: 
                    return 200;
                case 209: 
                    return 213;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Expr:
            switch (state) {
                case 66: 
                    return 119;
                case 72: 
                    return 125;
                case 104: 
                    return 153;
                case 108: 
                    return 156;
                case 145: 
                    return 185;
                case 152: case 204: 
                    return 190;
                case 167: case 209: 
                    return 201;
                case 198: 
                    return 206;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::VarStmt_OPT:
            switch (state) {
                case 73: 
                    return 126;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::VarStmt:
            switch (state) {
                case 52: case 55: case 57: case 58: case 110: 
                    return 60;
                case 73: 
                    return 127;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::LineEnding_OPT:
            switch (state) {
                case 47: 
                    return 53;
                case 65: 
                    return 118;
                case 156: 
                    return 193;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::LineEnding:
            switch (state) {
                case 11: 
                    return 29;
                case 43: 
                    return 48;
                case 47: case 65: case 156: 
                    return 54;
                case 64: 
                    return 117;
                case 66: 
                    return 120;
                case 113: 
                    return 159;
                case 119: 
                    return 162;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::TypeAnnotation_OPT:
            switch (state) {
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::TypeAnnotation:
            switch (state) {
                case 37: 
                    return 41;
                case 39: 
                    return 43;
                case 116: 
                    return 161;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::FunctionDecl:
            switch (state) {
                case 0: case 2: 
                    return 4;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ImplDecl:
            switch (state) {
                case 0: case 2: 
                    return 5;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Block:
            switch (state) {
                case 43: 
                    return 47;
                case 125: 
                    return 165;
                case 199: 
                    return 207;
                case 214: 
                    return 215;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::Type:
            switch (state) {
                case 7: 
                    return 11;
                case 27: case 90: 
                    return 32;
                case 42: 
                    return 46;
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 84;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ExprStmt:
            switch (state) {
                case 52: case 55: case 57: case 58: case 110: 
                    return 61;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::RetStmt:
            switch (state) {
                case 52: case 55: case 57: case 58: case 110: 
                    return 62;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::NotBlockedExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 110: 
                    return 64;
                case 66: case 72: case 104: case 108: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 122;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BlockedExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 110: 
                    return 65;
                case 66: case 72: case 104: case 108: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 121;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BracedBlock:
            switch (state) {
                case 43: case 125: case 199: case 214: 
                    return 49;
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 70;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::IndentedBlock:
            switch (state) {
                case 43: case 125: case 199: case 214: 
                    return 50;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::PrimitiveType:
            switch (state) {
                case 7: case 27: case 42: case 52: case 55: case 57: case 58: case 66: case 72: case 90: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 12;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::PointerType:
            switch (state) {
                case 7: case 27: case 42: case 52: case 55: case 57: case 58: case 66: case 72: case 90: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 13;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::AssignmentExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 67;
                case 123: 
                    return 163;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::IfExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 68;
                case 199: 
                    return 208;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::ForExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 69;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BinOrExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 71;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BinAndExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 74;
                case 124: 
                    return 164;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::CompEQExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 75;
                case 128: 
                    return 168;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::CompLGTExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 76;
                case 129: 
                    return 169;
                case 130: 
                    return 170;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BitXorExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 77;
                case 131: 
                    return 171;
                case 132: 
                    return 172;
                case 133: 
                    return 173;
                case 134: 
                    return 174;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BitOrExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 78;
                case 135: 
                    return 175;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BitAndExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 79;
                case 136: 
                    return 176;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::BitShiftExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 80;
                case 137: 
                    return 177;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::AdditionExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 81;
                case 138: 
                    return 178;
                case 139: 
                    return 179;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::MultExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 82;
                case 140: 
                    return 180;
                case 141: 
                    return 181;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::UnaryExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 85;
                case 86: 
                    return 146;
                case 87: 
                    return 148;
                case 88: 
                    return 149;
                case 89: 
                    return 150;
                case 90: case 147: 
                    return 151;
                case 142: 
                    return 182;
                case 143: 
                    return 183;
                case 144: 
                    return 184;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::CastExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 145: case 152: case 167: case 198: case 204: case 209: 
                    return 83;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::CallExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 86: case 87: case 88: case 89: case 90: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 147: case 152: case 167: case 198: case 204: case 209: 
                    return 91;
                default: reportAbortNoh("get invalid goto");
            }
        case NonTerminal::PrimaryExpr:
            switch (state) {
                case 52: case 55: case 57: case 58: case 66: case 72: case 86: case 87: case 88: case 89: case 90: case 104: case 108: case 110: case 123: case 124: case 128: case 129: case 130: case 131: case 132: case 133: case 134: case 135: case 136: case 137: case 138: case 139: case 140: case 141: case 142: case 143: case 144: case 145: case 147: case 152: case 167: case 198: case 204: case 209: 
                    return 92;
                default: reportAbortNoh("get invalid goto");
            }
    }
}
// This code was autogenerated - see the utils/ directory
// GETGOTO END
// }}}

static void shift(Parser &p, Token &last, Token &lookahead, std::vector<stackitem> &stack, int &steps, int const &newst) {
    last = lookahead;
    stack.emplace_back(newst, last);
    lookahead = p.consume();
    ++steps;
}

static Token popT(std::vector<stackitem> &stack) {
    stackitem si = std::move(stack.back());

    stack.pop_back();
    return std::get<tokenitem>(si.item).tok;
}

template <typename A>
static std::unique_ptr<A> popA(std::vector<stackitem> &stack) {
    stackitem si = std::move(stack.back());
    stack.pop_back();

    astitem &i = std::get<astitem>(si.item);
    A *astraw = dynamic_cast<A*>(i.ast.get());
    if (i.ast)
        ASSERT(astraw)
    i.ast.release(); // will only ever release if dynamic_cast works

    return std::unique_ptr<A>(astraw);
}

template <typename A>
static void reduceSkip(std::vector<stackitem> &stack) {
    size_t newstate = getGoto<A>((stack.end() - 2)->state);
    stack.back().state = newstate;
}

static void error(bool &done, bool &errored, errorstate const &ers, std::vector<std::string> const &expectations) {
    errored = true;

    if (!errorRecovery(ers, expectations))
        done = true;
}

bool _parse(Parser &p, std::vector<stackitem> &stack, bool istrial, std::unique_ptr<ASTNS::CUB> &out, Token const &_lookahead) {
    // parser loop {{{
    // PARSERLOOP START
// The following code was autogenerated - see the utils/ directory
    bool done = false;
    bool errored = false;
    int steps = 0;
    Token lookahead (_lookahead); // for when you need to inject a new token
    Token lasttok = lookahead;
    while (!done) {
        if (istrial && steps > 5)
            return true;
        switch (stack.back().state) {
            case 0:
                switch (lookahead.type) {
                    default: {
                            std::unique_ptr<ASTNS::CU> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::CU, stack.back().state), std::move(pushitem), NonTerminal::CU);
                        }
                        break;
                    case TokenType::FUN:
                        shift(p, lasttok, lookahead, stack, steps, 6); break;
                    case TokenType::IMPL:
                        shift(p, lasttok, lookahead, stack, steps, 7); break;
                }
                break;
            case 1:
                switch (lookahead.type) {
                    case TokenType::EOF_:
                            done = true;
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % to terminate %", stringifyTokenType(TokenType::EOF_), "augment")  });
                }
                break;
            case 2:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::DeclList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
std::unique_ptr<ASTNS::CU> push (std::make_unique<ASTNS::CU>(p.sourcefile, start, end, std::move(a0)));
                            std::unique_ptr<ASTNS::CU> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CU, stack.back().state), std::move(pushitem), NonTerminal::CU);
                        }
                        break;
                    case TokenType::FUN:
                        shift(p, lasttok, lookahead, stack, steps, 6); break;
                    case TokenType::IMPL:
                        shift(p, lasttok, lookahead, stack, steps, 7); break;
                }
                break;
            case 3:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Decl>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
std::unique_ptr<ASTNS::DeclList> push(std::make_unique<ASTNS::DeclList>(p.sourcefile, start, end, std::vector<std::unique_ptr<ASTNS::Decl>> {}));

        push->decls.push_back(std::move(a0));
                            std::unique_ptr<ASTNS::DeclList> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::DeclList, stack.back().state), std::move(pushitem), NonTerminal::DeclList);
                        }
                        break;
                }
                break;
            case 4:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::FunctionDecl>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Decl> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Decl, stack.back().state), std::move(pushitem), NonTerminal::Decl);
                        }
                        break;
                }
                break;
            case 5:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::ImplDecl>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Decl> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Decl, stack.back().state), std::move(pushitem), NonTerminal::Decl);
                        }
                        break;
                }
                break;
            case 6:
                switch (lookahead.type) {
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 10); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::IDENTIFIER), "function declaration")  });
                }
                break;
            case 7:
                switch (lookahead.type) {
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 27); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "type specifier", "implementation")  });
                }
                break;
            case 8:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Decl>(stack));
                            auto a0 (popA<ASTNS::DeclList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            else if (a1) start = a1->start();
                            if (a1) end = a1->end();
                            else if (a0) end = a0->end();
a0->decls.push_back(std::move(a1));
                            std::unique_ptr<ASTNS::DeclList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::DeclList, stack.back().state), std::move(pushitem), NonTerminal::DeclList);
                        }
                        break;
                }
                break;
            case 9:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Decl>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Decl> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::AnotherDecl, stack.back().state), std::move(pushitem), NonTerminal::AnotherDecl);
                        }
                        break;
                }
                break;
            case 10:
                switch (lookahead.type) {
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 28); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::OPARN), "function declaration")  });
                }
                break;
            case 11:
                switch (lookahead.type) {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "line ending", "implementation")  });
                }
                break;
            case 12:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::PrimitiveType>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Type> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Type, stack.back().state), std::move(pushitem), NonTerminal::Type);
                        }
                        break;
                }
                break;
            case 13:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::PointerType>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Type> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Type, stack.back().state), std::move(pushitem), NonTerminal::Type);
                        }
                        break;
                }
                break;
            case 14:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 15:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 16:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 17:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 18:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 19:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 20:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 21:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 22:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 23:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 24:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 25:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 26:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimitiveType> push (std::make_unique<ASTNS::PrimitiveType>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::PrimitiveType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimitiveType, stack.back().state), std::move(pushitem), NonTerminal::PrimitiveType);
                        }
                        break;
                }
                break;
            case 27:
                switch (lookahead.type) {
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 27); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "type specifier", "pointer type specifier")  });
                }
                break;
            case 28:
                switch (lookahead.type) {
                    case TokenType::CPARN:
{
                            std::unique_ptr<ASTNS::ParamList> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::ParamList_OPT, stack.back().state), std::move(pushitem), NonTerminal::ParamList_OPT);
                        }
                        break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 37); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional parameter list", "function declaration")  });
                }
                break;
            case 29:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::PureLocation>(stack));
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a2) end = a2->end();
                            else if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::ImplDecl> push (std::make_unique<ASTNS::ImplDecl>(p.sourcefile, start, end, std::move(a1)));
                            std::unique_ptr<ASTNS::ImplDecl> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::ImplDecl, stack.back().state), std::move(pushitem), NonTerminal::ImplDecl);
                        }
                        break;
                }
                break;
            case 30:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PureLocation> push (std::make_unique<ASTNS::PureLocation>(p.sourcefile, start, end, 0));
                            std::unique_ptr<ASTNS::PureLocation> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::LineEnding, stack.back().state), std::move(pushitem), NonTerminal::LineEnding);
                        }
                        break;
                }
                break;
            case 31:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PureLocation> push (std::make_unique<ASTNS::PureLocation>(p.sourcefile, start, end, 0));
                            std::unique_ptr<ASTNS::PureLocation> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::LineEnding, stack.back().state), std::move(pushitem), NonTerminal::LineEnding);
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                }
                break;
            case 32:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::PointerType> push (std::make_unique<ASTNS::PointerType>(p.sourcefile, start, end, std::move(a1)));
                            std::unique_ptr<ASTNS::PointerType> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PointerType, stack.back().state), std::move(pushitem), NonTerminal::PointerType);
                        }
                        break;
                }
                break;
            case 33:
                switch (lookahead.type) {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "function declaration")  });
                }
                break;
            case 34:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::ParamList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::ParamList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ParamList_OPT, stack.back().state), std::move(pushitem), NonTerminal::ParamList_OPT);
                        }
                        break;
                }
                break;
            case 35:
                switch (lookahead.type) {
                    case TokenType::COMMA:
                        shift(p, lasttok, lookahead, stack, steps, 40); break;
                    default: {
                            auto a0 (popA<ASTNS::ParamList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::ParamList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ParamList, stack.back().state), std::move(pushitem), NonTerminal::ParamList);
                        }
                        break;
                }
                break;
            case 36:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Param>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
std::unique_ptr<ASTNS::ParamList> push(std::make_unique<ASTNS::ParamList>(p.sourcefile, start, end, std::vector<std::unique_ptr<ASTNS::Param>> {}));

        push->params.push_back(std::move(a0));
                            std::unique_ptr<ASTNS::ParamList> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::ParamSegment, stack.back().state), std::move(pushitem), NonTerminal::ParamSegment);
                        }
                        break;
                }
                break;
            case 37:
                switch (lookahead.type) {
                    case TokenType::COLON:
                        shift(p, lasttok, lookahead, stack, steps, 42); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "required type annotation", "parameter")  });
                }
                break;
            case 38:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a1;
WARN_EXTRA_SEMI(a0);std::unique_ptr<ASTNS::PureLocation> push (std::make_unique<ASTNS::PureLocation>(p.sourcefile, start, end, 0));
                            std::unique_ptr<ASTNS::PureLocation> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::LineEnding, stack.back().state), std::move(pushitem), NonTerminal::LineEnding);
                        }
                        break;
                }
                break;
            case 39:
                switch (lookahead.type) {
                    case TokenType::COLON:
                        shift(p, lasttok, lookahead, stack, steps, 42); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "required type annotation", "function declaration")  });
                }
                break;
            case 40:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ParamList>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            end = a1;
                            std::unique_ptr<ASTNS::ParamList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ParamList, stack.back().state), std::move(pushitem), NonTerminal::ParamList);
                        }
                        break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 37); break;
                }
                break;
            case 41:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::Param> push (std::make_unique<ASTNS::Param>(p.sourcefile, start, end, std::move(a1), a0));
                            std::unique_ptr<ASTNS::Param> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::Param, stack.back().state), std::move(pushitem), NonTerminal::Param);
                        }
                        break;
                }
                break;
            case 42:
                switch (lookahead.type) {
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 27); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "type specifier", "required type annotation")  });
                }
                break;
            case 43:
                switch (lookahead.type) {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 51); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "code block", "line ending"), "function declaration")  });
                }
                break;
            case 44:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Param>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ParamList>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
a0->params.push_back(std::move(a2));
                            std::unique_ptr<ASTNS::ParamList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ParamSegment, stack.back().state), std::move(pushitem), NonTerminal::ParamSegment);
                        }
                        break;
                }
                break;
            case 45:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Param>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Param> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::AnotherParam, stack.back().state), std::move(pushitem), NonTerminal::AnotherParam);
                        }
                        break;
                }
                break;
            case 46:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
                            std::unique_ptr<ASTNS::Type> pushitem = std::move(a1);
                            stack.emplace_back(getGoto(NonTerminal::TypeAnnotation, stack.back().state), std::move(pushitem), NonTerminal::TypeAnnotation);
                        }
                        break;
                }
                break;
            case 47:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                    case TokenType::BANG:
                    case TokenType::BININTLIT:
                    case TokenType::BOOL:
                    case TokenType::CCURB:
                    case TokenType::CHAR:
                    case TokenType::CHARLIT:
                    case TokenType::DECINTLIT:
                    case TokenType::DEDENT:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FALSELIT:
                    case TokenType::FLOAT:
                    case TokenType::FLOATLIT:
                    case TokenType::FOR:
                    case TokenType::FUN:
                    case TokenType::HEXINTLIT:
                    case TokenType::IDENTIFIER:
                    case TokenType::IF:
                    case TokenType::IMPL:
                    case TokenType::LEFTARROW:
                    case TokenType::MINUS:
                    case TokenType::NULLPTRLIT:
                    case TokenType::OCTINTLIT:
                    case TokenType::OCURB:
                    case TokenType::OPARN:
                    case TokenType::RETURN:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::STAR:
                    case TokenType::STRINGLIT:
                    case TokenType::TILDE:
                    case TokenType::TRUELIT:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VAR:
                    case TokenType::VOID:
{
                            std::unique_ptr<ASTNS::PureLocation> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::LineEnding_OPT, stack.back().state), std::move(pushitem), NonTerminal::LineEnding_OPT);
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional line ending", "function declaration")  });
                }
                break;
            case 48:
                switch (lookahead.type) {
                    default: {
                            auto a6 (popA<ASTNS::PureLocation>(stack));
                            auto a5 (popA<ASTNS::Type>(stack));
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::ParamList>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a6) end = a6->end();
                            else if (a5) end = a5->end();
                            else end = a4;
std::unique_ptr<ASTNS::FunctionDecl> push (std::make_unique<ASTNS::FunctionDecl>(p.sourcefile, start, end, std::move(a5), a1, std::move(a3), nullptr));
                            std::unique_ptr<ASTNS::FunctionDecl> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::FunctionDecl, stack.back().state), std::move(pushitem), NonTerminal::FunctionDecl);
                        }
                        break;
                }
                break;
            case 49:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Block>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Block> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Block, stack.back().state), std::move(pushitem), NonTerminal::Block);
                        }
                        break;
                }
                break;
            case 50:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Block>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Block> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Block, stack.back().state), std::move(pushitem), NonTerminal::Block);
                        }
                        break;
                }
                break;
            case 51:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PureLocation> push (std::make_unique<ASTNS::PureLocation>(p.sourcefile, start, end, 0));
                            std::unique_ptr<ASTNS::PureLocation> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::LineEnding, stack.back().state), std::move(pushitem), NonTerminal::LineEnding);
                        }
                        break;
                    case TokenType::INDENT:
                        shift(p, lasttok, lookahead, stack, steps, 55); break;
                }
                break;
            case 52:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
                    case TokenType::LEFTARROW:
{
                            std::unique_ptr<ASTNS::StmtList> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::StmtList_OPT, stack.back().state), std::move(pushitem), NonTerminal::StmtList_OPT);
                        }
                        break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 57); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 66); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "optional statement list", stringifyTokenType(TokenType::NEWLINE)), "braced code block")  });
                }
                break;
            case 53:
                switch (lookahead.type) {
                    default: {
                            auto a7 (popA<ASTNS::PureLocation>(stack));
                            auto a6 (popA<ASTNS::Block>(stack));
                            auto a5 (popA<ASTNS::Type>(stack));
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::ParamList>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a7) end = a7->end();
                            else if (a6) end = a6->end();
                            else if (a5) end = a5->end();
                            else end = a4;
std::unique_ptr<ASTNS::FunctionDecl> push (std::make_unique<ASTNS::FunctionDecl>(p.sourcefile, start, end, std::move(a5), a1, std::move(a3), std::move(a6)));
                            std::unique_ptr<ASTNS::FunctionDecl> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::FunctionDecl, stack.back().state), std::move(pushitem), NonTerminal::FunctionDecl);
                        }
                        break;
                }
                break;
            case 54:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::PureLocation>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::PureLocation> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::LineEnding_OPT, stack.back().state), std::move(pushitem), NonTerminal::LineEnding_OPT);
                        }
                        break;
                }
                break;
            case 55:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
                    case TokenType::LEFTARROW:
{
                            std::unique_ptr<ASTNS::StmtList> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::StmtList_OPT, stack.back().state), std::move(pushitem), NonTerminal::StmtList_OPT);
                        }
                        break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 66); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional statement list", "indented code block")  });
                }
                break;
            case 56:
                switch (lookahead.type) {
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
{
                            std::unique_ptr<ASTNS::ImplRet> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::ImplRet_OPT, stack.back().state), std::move(pushitem), NonTerminal::ImplRet_OPT);
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 108); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional block return value", "braced code block")  });
                }
                break;
            case 57:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
                    case TokenType::LEFTARROW:
{
                            std::unique_ptr<ASTNS::StmtList> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::StmtList_OPT, stack.back().state), std::move(pushitem), NonTerminal::StmtList_OPT);
                        }
                        break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::INDENT:
                        shift(p, lasttok, lookahead, stack, steps, 110); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 66); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "optional statement list", stringifyTokenType(TokenType::INDENT)), "braced code block")  });
                }
                break;
            case 58:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    default: {
                            auto a0 (popA<ASTNS::StmtList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::StmtList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::StmtList_OPT, stack.back().state), std::move(pushitem), NonTerminal::StmtList_OPT);
                        }
                        break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 66); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                }
                break;
            case 59:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Stmt>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
std::unique_ptr<ASTNS::StmtList> push(std::make_unique<ASTNS::StmtList>(p.sourcefile, start, end, std::vector<std::unique_ptr<ASTNS::Stmt>> {}));

        push->stmts.push_back(std::move(a0));
                            std::unique_ptr<ASTNS::StmtList> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::StmtList, stack.back().state), std::move(pushitem), NonTerminal::StmtList);
                        }
                        break;
                }
                break;
            case 60:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::VarStmt>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Stmt> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Stmt, stack.back().state), std::move(pushitem), NonTerminal::Stmt);
                        }
                        break;
                }
                break;
            case 61:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::ExprStmt>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Stmt> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Stmt, stack.back().state), std::move(pushitem), NonTerminal::Stmt);
                        }
                        break;
                }
                break;
            case 62:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::RetStmt>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Stmt> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Stmt, stack.back().state), std::move(pushitem), NonTerminal::Stmt);
                        }
                        break;
                }
                break;
            case 63:
                switch (lookahead.type) {
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 116); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "variable statement initialization list", "variable statement")  });
                }
                break;
            case 64:
                switch (lookahead.type) {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "line ending", "expression statement")  });
                }
                break;
            case 65:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                    case TokenType::BANG:
                    case TokenType::BININTLIT:
                    case TokenType::BOOL:
                    case TokenType::CCURB:
                    case TokenType::CHAR:
                    case TokenType::CHARLIT:
                    case TokenType::DECINTLIT:
                    case TokenType::DEDENT:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FALSELIT:
                    case TokenType::FLOAT:
                    case TokenType::FLOATLIT:
                    case TokenType::FOR:
                    case TokenType::FUN:
                    case TokenType::HEXINTLIT:
                    case TokenType::IDENTIFIER:
                    case TokenType::IF:
                    case TokenType::IMPL:
                    case TokenType::LEFTARROW:
                    case TokenType::MINUS:
                    case TokenType::NULLPTRLIT:
                    case TokenType::OCTINTLIT:
                    case TokenType::OCURB:
                    case TokenType::OPARN:
                    case TokenType::RETURN:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::STAR:
                    case TokenType::STRINGLIT:
                    case TokenType::TILDE:
                    case TokenType::TRUELIT:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VAR:
                    case TokenType::VOID:
{
                            std::unique_ptr<ASTNS::PureLocation> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::LineEnding_OPT, stack.back().state), std::move(pushitem), NonTerminal::LineEnding_OPT);
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional line ending", "expression statement")  });
                }
                break;
            case 66:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "expression", "line ending"), "return statement")  });
                }
                break;
            case 67:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::NotBlockedExpr, stack.back().state), std::move(pushitem), NonTerminal::NotBlockedExpr);
                        }
                        break;
                }
                break;
            case 68:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::IfExpr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BlockedExpr, stack.back().state), std::move(pushitem), NonTerminal::BlockedExpr);
                        }
                        break;
                }
                break;
            case 69:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::ForExpr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BlockedExpr, stack.back().state), std::move(pushitem), NonTerminal::BlockedExpr);
                        }
                        break;
                }
                break;
            case 70:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Block>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BlockedExpr, stack.back().state), std::move(pushitem), NonTerminal::BlockedExpr);
                        }
                        break;
                }
                break;
            case 71:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::AssignmentExpr, stack.back().state), std::move(pushitem), NonTerminal::AssignmentExpr);
                        }
                        break;
                    case TokenType::DOUBLEPIPE:
                        shift(p, lasttok, lookahead, stack, steps, 124); break;
                    case TokenType::EQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 123); break;
                }
                break;
            case 72:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "if expression")  });
                }
                break;
            case 73:
                switch (lookahead.type) {
                    case TokenType::SEMICOLON:
{
                            std::unique_ptr<ASTNS::VarStmt> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::VarStmt_OPT, stack.back().state), std::move(pushitem), NonTerminal::VarStmt_OPT);
                        }
                        break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional variable statement", "for expression")  });
                }
                break;
            case 74:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BinOrExpr, stack.back().state), std::move(pushitem), NonTerminal::BinOrExpr);
                        }
                        break;
                    case TokenType::DOUBLEAMPER:
                        shift(p, lasttok, lookahead, stack, steps, 128); break;
                }
                break;
            case 75:
                switch (lookahead.type) {
                    case TokenType::BANGEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 129); break;
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BinAndExpr, stack.back().state), std::move(pushitem), NonTerminal::BinAndExpr);
                        }
                        break;
                    case TokenType::DOUBLEEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 130); break;
                }
                break;
            case 76:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::CompEQExpr, stack.back().state), std::move(pushitem), NonTerminal::CompEQExpr);
                        }
                        break;
                    case TokenType::GREATER:
                        shift(p, lasttok, lookahead, stack, steps, 132); break;
                    case TokenType::GREATEREQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 134); break;
                    case TokenType::LESS:
                        shift(p, lasttok, lookahead, stack, steps, 131); break;
                    case TokenType::LESSEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                }
                break;
            case 77:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::CompLGTExpr, stack.back().state), std::move(pushitem), NonTerminal::CompLGTExpr);
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 135); break;
                }
                break;
            case 78:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BitXorExpr, stack.back().state), std::move(pushitem), NonTerminal::BitXorExpr);
                        }
                        break;
                    case TokenType::PIPE:
                        shift(p, lasttok, lookahead, stack, steps, 136); break;
                }
                break;
            case 79:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 137); break;
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BitOrExpr, stack.back().state), std::move(pushitem), NonTerminal::BitOrExpr);
                        }
                        break;
                }
                break;
            case 80:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BitAndExpr, stack.back().state), std::move(pushitem), NonTerminal::BitAndExpr);
                        }
                        break;
                    case TokenType::DOUBLEGREATER:
                        shift(p, lasttok, lookahead, stack, steps, 138); break;
                    case TokenType::DOUBLELESS:
                        shift(p, lasttok, lookahead, stack, steps, 139); break;
                }
                break;
            case 81:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::BitShiftExpr, stack.back().state), std::move(pushitem), NonTerminal::BitShiftExpr);
                        }
                        break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 141); break;
                    case TokenType::PLUS:
                        shift(p, lasttok, lookahead, stack, steps, 140); break;
                }
                break;
            case 82:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::AdditionExpr, stack.back().state), std::move(pushitem), NonTerminal::AdditionExpr);
                        }
                        break;
                    case TokenType::PERCENT:
                        shift(p, lasttok, lookahead, stack, steps, 144); break;
                    case TokenType::SLASH:
                        shift(p, lasttok, lookahead, stack, steps, 143); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 142); break;
                }
                break;
            case 83:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::MultExpr, stack.back().state), std::move(pushitem), NonTerminal::MultExpr);
                        }
                        break;
                }
                break;
            case 84:
                switch (lookahead.type) {
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 145); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::OPARN), "type cast expression")  });
                }
                break;
            case 85:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::CastExpr, stack.back().state), std::move(pushitem), NonTerminal::CastExpr);
                        }
                        break;
                }
                break;
            case 86:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 87:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 88:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 89:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 90:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression"), format("expected % for %", "type specifier", "pointer type specifier")  });
                }
                break;
            case 91:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::UnaryExpr, stack.back().state), std::move(pushitem), NonTerminal::UnaryExpr);
                        }
                        break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 152); break;
                }
                break;
            case 92:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::CallExpr, stack.back().state), std::move(pushitem), NonTerminal::CallExpr);
                        }
                        break;
                }
                break;
            case 93:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 94:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 95:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 96:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 97:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 98:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 99:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 100:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 101:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 102:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 103:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a0;
std::unique_ptr<ASTNS::PrimaryExpr> push (std::make_unique<ASTNS::PrimaryExpr>(p.sourcefile, start, end, a0));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 104:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "primary expression")  });
                }
                break;
            case 105:
                switch (lookahead.type) {
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
{
                            std::unique_ptr<ASTNS::ImplRet> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::ImplRet_OPT, stack.back().state), std::move(pushitem), NonTerminal::ImplRet_OPT);
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 108); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional block return value", "indented code block")  });
                }
                break;
            case 106:
                switch (lookahead.type) {
                    case TokenType::CCURB:
                        shift(p, lasttok, lookahead, stack, steps, 155); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CCURB), "braced code block")  });
                }
                break;
            case 107:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::ImplRet>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::ImplRet> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ImplRet_OPT, stack.back().state), std::move(pushitem), NonTerminal::ImplRet_OPT);
                        }
                        break;
                }
                break;
            case 108:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "block return value")  });
                }
                break;
            case 109:
                switch (lookahead.type) {
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
{
                            std::unique_ptr<ASTNS::ImplRet> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::ImplRet_OPT, stack.back().state), std::move(pushitem), NonTerminal::ImplRet_OPT);
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 108); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional block return value", "braced code block")  });
                }
                break;
            case 110:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
                    case TokenType::LEFTARROW:
{
                            std::unique_ptr<ASTNS::StmtList> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::StmtList_OPT, stack.back().state), std::move(pushitem), NonTerminal::StmtList_OPT);
                        }
                        break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 66); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional statement list", "braced code block")  });
                }
                break;
            case 111:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Stmt>(stack));
                            auto a0 (popA<ASTNS::StmtList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            else if (a1) start = a1->start();
                            if (a1) end = a1->end();
                            else if (a0) end = a0->end();
a0->stmts.push_back(std::move(a1));
                            std::unique_ptr<ASTNS::StmtList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::StmtList, stack.back().state), std::move(pushitem), NonTerminal::StmtList);
                        }
                        break;
                }
                break;
            case 112:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Stmt>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Stmt> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::AnotherStmt, stack.back().state), std::move(pushitem), NonTerminal::AnotherStmt);
                        }
                        break;
                }
                break;
            case 113:
                switch (lookahead.type) {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "line ending", "variable statement")  });
                }
                break;
            case 114:
                switch (lookahead.type) {
                    case TokenType::COMMA:
                        shift(p, lasttok, lookahead, stack, steps, 160); break;
                    default: {
                            auto a0 (popA<ASTNS::VarStmtItemList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::VarStmtItemList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::VarStmtItemList, stack.back().state), std::move(pushitem), NonTerminal::VarStmtItemList);
                        }
                        break;
                }
                break;
            case 115:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::VarStmtItem>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
std::unique_ptr<ASTNS::VarStmtItemList> push(std::make_unique<ASTNS::VarStmtItemList>(p.sourcefile, start, end, std::vector<std::unique_ptr<ASTNS::VarStmtItem>> {}));

        push->items.push_back(std::move(a0));
                            std::unique_ptr<ASTNS::VarStmtItemList> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::VarStmtItemSegment, stack.back().state), std::move(pushitem), NonTerminal::VarStmtItemSegment);
                        }
                        break;
                }
                break;
            case 116:
                switch (lookahead.type) {
                    case TokenType::COLON:
                        shift(p, lasttok, lookahead, stack, steps, 42); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "required type annotation", "variable statement initialization")  });
                }
                break;
            case 117:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::PureLocation>(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            else if (a1) start = a1->start();
                            if (a1) end = a1->end();
                            else if (a0) end = a0->end();
std::unique_ptr<ASTNS::ExprStmt> push (std::make_unique<ASTNS::ExprStmt>(p.sourcefile, start, end, std::move(a0)));
                            std::unique_ptr<ASTNS::ExprStmt> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::ExprStmt, stack.back().state), std::move(pushitem), NonTerminal::ExprStmt);
                        }
                        break;
                }
                break;
            case 118:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::PureLocation>(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            else if (a1) start = a1->start();
                            if (a1) end = a1->end();
                            else if (a0) end = a0->end();
std::unique_ptr<ASTNS::ExprStmt> push (std::make_unique<ASTNS::ExprStmt>(p.sourcefile, start, end, std::move(a0)));
                            std::unique_ptr<ASTNS::ExprStmt> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::ExprStmt, stack.back().state), std::move(pushitem), NonTerminal::ExprStmt);
                        }
                        break;
                }
                break;
            case 119:
                switch (lookahead.type) {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "line ending", "return statement")  });
                }
                break;
            case 120:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::PureLocation>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::RetStmt> push (std::make_unique<ASTNS::RetStmt>(p.sourcefile, start, end, nullptr));
                            std::unique_ptr<ASTNS::RetStmt> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::RetStmt, stack.back().state), std::move(pushitem), NonTerminal::RetStmt);
                        }
                        break;
                }
                break;
            case 121:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Expr, stack.back().state), std::move(pushitem), NonTerminal::Expr);
                        }
                        break;
                }
                break;
            case 122:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Expr, stack.back().state), std::move(pushitem), NonTerminal::Expr);
                        }
                        break;
                }
                break;
            case 123:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "assignment expression", "assignment expression")  });
                }
                break;
            case 124:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "binary and expression", "binary or expression")  });
                }
                break;
            case 125:
                switch (lookahead.type) {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 166); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "code block", "if expression")  });
                }
                break;
            case 126:
                switch (lookahead.type) {
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 167); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::SEMICOLON), "for expression")  });
                }
                break;
            case 127:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::VarStmt>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::VarStmt> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::VarStmt_OPT, stack.back().state), std::move(pushitem), NonTerminal::VarStmt_OPT);
                        }
                        break;
                }
                break;
            case 128:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "equality expression", "binary and expression")  });
                }
                break;
            case 129:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "comparison expression", "equality expression")  });
                }
                break;
            case 130:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "comparison expression", "equality expression")  });
                }
                break;
            case 131:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 132:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 133:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 134:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 135:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise or expression", "bitwise xor expression")  });
                }
                break;
            case 136:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise and expression", "bitwise or expression")  });
                }
                break;
            case 137:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bit shift expression", "bitwise and expression")  });
                }
                break;
            case 138:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "addition expression", "bit shift expression")  });
                }
                break;
            case 139:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "addition expression", "bit shift expression")  });
                }
                break;
            case 140:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "multiplication expression", "addition expression")  });
                }
                break;
            case 141:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "multiplication expression", "addition expression")  });
                }
                break;
            case 142:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "multiplication expression")  });
                }
                break;
            case 143:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "multiplication expression")  });
                }
                break;
            case 144:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "multiplication expression")  });
                }
                break;
            case 145:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "type cast expression")  });
                }
                break;
            case 146:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::UnaryExpr> push (std::make_unique<ASTNS::UnaryExpr>(p.sourcefile, start, end, a0, std::move(a1)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::UnaryExpr, stack.back().state), std::move(pushitem), NonTerminal::UnaryExpr);
                        }
                        break;
                }
                break;
            case 147:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 147); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 148:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::UnaryExpr> push (std::make_unique<ASTNS::UnaryExpr>(p.sourcefile, start, end, a0, std::move(a1)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::UnaryExpr, stack.back().state), std::move(pushitem), NonTerminal::UnaryExpr);
                        }
                        break;
                }
                break;
            case 149:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::UnaryExpr> push (std::make_unique<ASTNS::UnaryExpr>(p.sourcefile, start, end, a0, std::move(a1)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::UnaryExpr, stack.back().state), std::move(pushitem), NonTerminal::UnaryExpr);
                        }
                        break;
                }
                break;
            case 150:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::AddrofExpr> push (std::make_unique<ASTNS::AddrofExpr>(p.sourcefile, start, end, a0, std::move(a1)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::UnaryExpr, stack.back().state), std::move(pushitem), NonTerminal::UnaryExpr);
                        }
                        break;
                }
                break;
            case 151:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::DerefExpr> push (std::make_unique<ASTNS::DerefExpr>(p.sourcefile, start, end, a0, std::move(a1)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::UnaryExpr, stack.back().state), std::move(pushitem), NonTerminal::UnaryExpr);
                        }
                        break;
                }
                break;
            case 152:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::CPARN:
{
                            std::unique_ptr<ASTNS::ArgList> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::ArgList_OPT, stack.back().state), std::move(pushitem), NonTerminal::ArgList_OPT);
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional argument list", "function call expression")  });
                }
                break;
            case 153:
                switch (lookahead.type) {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 191); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "primary expression")  });
                }
                break;
            case 154:
                switch (lookahead.type) {
                    case TokenType::DEDENT:
                        shift(p, lasttok, lookahead, stack, steps, 192); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::DEDENT), "indented code block")  });
                }
                break;
            case 155:
                switch (lookahead.type) {
                    default: {
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::ImplRet>(stack));
                            auto a1 (popA<ASTNS::StmtList>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a3;
std::unique_ptr<ASTNS::Block> push (std::make_unique<ASTNS::Block>(p.sourcefile, start, end, std::move(a1), std::move(a2)));
                            std::unique_ptr<ASTNS::Block> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BracedBlock, stack.back().state), std::move(pushitem), NonTerminal::BracedBlock);
                        }
                        break;
                }
                break;
            case 156:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                    case TokenType::BANG:
                    case TokenType::BININTLIT:
                    case TokenType::BOOL:
                    case TokenType::CCURB:
                    case TokenType::CHAR:
                    case TokenType::CHARLIT:
                    case TokenType::DECINTLIT:
                    case TokenType::DEDENT:
                    case TokenType::DOUBLE:
                    case TokenType::EOF_:
                    case TokenType::FALSELIT:
                    case TokenType::FLOAT:
                    case TokenType::FLOATLIT:
                    case TokenType::FOR:
                    case TokenType::FUN:
                    case TokenType::HEXINTLIT:
                    case TokenType::IDENTIFIER:
                    case TokenType::IF:
                    case TokenType::IMPL:
                    case TokenType::LEFTARROW:
                    case TokenType::MINUS:
                    case TokenType::NULLPTRLIT:
                    case TokenType::OCTINTLIT:
                    case TokenType::OCURB:
                    case TokenType::OPARN:
                    case TokenType::RETURN:
                    case TokenType::SINT16:
                    case TokenType::SINT32:
                    case TokenType::SINT64:
                    case TokenType::SINT8:
                    case TokenType::STAR:
                    case TokenType::STRINGLIT:
                    case TokenType::TILDE:
                    case TokenType::TRUELIT:
                    case TokenType::UINT16:
                    case TokenType::UINT32:
                    case TokenType::UINT64:
                    case TokenType::UINT8:
                    case TokenType::VAR:
                    case TokenType::VOID:
{
                            std::unique_ptr<ASTNS::PureLocation> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::LineEnding_OPT, stack.back().state), std::move(pushitem), NonTerminal::LineEnding_OPT);
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional line ending", "block return value")  });
                }
                break;
            case 157:
                switch (lookahead.type) {
                    case TokenType::CCURB:
                        shift(p, lasttok, lookahead, stack, steps, 194); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CCURB), "braced code block")  });
                }
                break;
            case 158:
                switch (lookahead.type) {
                    case TokenType::CCURB:
                    case TokenType::DEDENT:
{
                            std::unique_ptr<ASTNS::ImplRet> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::ImplRet_OPT, stack.back().state), std::move(pushitem), NonTerminal::ImplRet_OPT);
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 108); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional block return value", "braced code block")  });
                }
                break;
            case 159:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::PureLocation>(stack));
                            auto a1 (popA<ASTNS::VarStmtItemList>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a2) end = a2->end();
                            else if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::VarStmt> push (std::make_unique<ASTNS::VarStmt>(p.sourcefile, start, end, std::move(a1)));
                            std::unique_ptr<ASTNS::VarStmt> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::VarStmt, stack.back().state), std::move(pushitem), NonTerminal::VarStmt);
                        }
                        break;
                }
                break;
            case 160:
                switch (lookahead.type) {
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 116); break;
                    default: {
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::VarStmtItemList>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            end = a1;
                            std::unique_ptr<ASTNS::VarStmtItemList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::VarStmtItemList, stack.back().state), std::move(pushitem), NonTerminal::VarStmtItemList);
                        }
                        break;
                }
                break;
            case 161:
                switch (lookahead.type) {
                    default: {
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::VarStmtItem> push (std::make_unique<ASTNS::VarStmtItem>(p.sourcefile, start, end, std::move(a1), a0, a0, nullptr));
                            std::unique_ptr<ASTNS::VarStmtItem> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::VarStmtItem, stack.back().state), std::move(pushitem), NonTerminal::VarStmtItem);
                        }
                        break;
                    case TokenType::EQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 198); break;
                }
                break;
            case 162:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::PureLocation>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a2) end = a2->end();
                            else if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::RetStmt> push (std::make_unique<ASTNS::RetStmt>(p.sourcefile, start, end, std::move(a1)));
                            std::unique_ptr<ASTNS::RetStmt> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::RetStmt, stack.back().state), std::move(pushitem), NonTerminal::RetStmt);
                        }
                        break;
                }
                break;
            case 163:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::AssignmentExpr> push (std::make_unique<ASTNS::AssignmentExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::AssignmentExpr, stack.back().state), std::move(pushitem), NonTerminal::AssignmentExpr);
                        }
                        break;
                }
                break;
            case 164:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::ShortCircuitExpr> push (std::make_unique<ASTNS::ShortCircuitExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BinOrExpr, stack.back().state), std::move(pushitem), NonTerminal::BinOrExpr);
                        }
                        break;
                    case TokenType::DOUBLEAMPER:
                        shift(p, lasttok, lookahead, stack, steps, 128); break;
                }
                break;
            case 165:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Block>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a2) end = a2->end();
                            else if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::IfExpr> push (std::make_unique<ASTNS::IfExpr>(p.sourcefile, start, end, a0, std::move(a1), std::move(a2), nullptr));
                            std::unique_ptr<ASTNS::IfExpr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::IfExpr, stack.back().state), std::move(pushitem), NonTerminal::IfExpr);
                        }
                        break;
                    case TokenType::ELSE:
                        shift(p, lasttok, lookahead, stack, steps, 199); break;
                }
                break;
            case 166:
                switch (lookahead.type) {
                    case TokenType::INDENT:
                        shift(p, lasttok, lookahead, stack, steps, 55); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::INDENT), "indented code block")  });
                }
                break;
            case 167:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::CPARN:
                    case TokenType::SEMICOLON:
{
                            std::unique_ptr<ASTNS::Expr> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::Expr_OPT, stack.back().state), std::move(pushitem), NonTerminal::Expr_OPT);
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional expression", "for expression")  });
                }
                break;
            case 168:
                switch (lookahead.type) {
                    case TokenType::BANGEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 129); break;
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::ShortCircuitExpr> push (std::make_unique<ASTNS::ShortCircuitExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BinAndExpr, stack.back().state), std::move(pushitem), NonTerminal::BinAndExpr);
                        }
                        break;
                    case TokenType::DOUBLEEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 130); break;
                }
                break;
            case 169:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CompEQExpr, stack.back().state), std::move(pushitem), NonTerminal::CompEQExpr);
                        }
                        break;
                    case TokenType::GREATER:
                        shift(p, lasttok, lookahead, stack, steps, 132); break;
                    case TokenType::GREATEREQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 134); break;
                    case TokenType::LESS:
                        shift(p, lasttok, lookahead, stack, steps, 131); break;
                    case TokenType::LESSEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                }
                break;
            case 170:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CompEQExpr, stack.back().state), std::move(pushitem), NonTerminal::CompEQExpr);
                        }
                        break;
                    case TokenType::GREATER:
                        shift(p, lasttok, lookahead, stack, steps, 132); break;
                    case TokenType::GREATEREQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 134); break;
                    case TokenType::LESS:
                        shift(p, lasttok, lookahead, stack, steps, 131); break;
                    case TokenType::LESSEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                }
                break;
            case 171:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CompLGTExpr, stack.back().state), std::move(pushitem), NonTerminal::CompLGTExpr);
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 135); break;
                }
                break;
            case 172:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CompLGTExpr, stack.back().state), std::move(pushitem), NonTerminal::CompLGTExpr);
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 135); break;
                }
                break;
            case 173:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CompLGTExpr, stack.back().state), std::move(pushitem), NonTerminal::CompLGTExpr);
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 135); break;
                }
                break;
            case 174:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CompLGTExpr, stack.back().state), std::move(pushitem), NonTerminal::CompLGTExpr);
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 135); break;
                }
                break;
            case 175:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BitXorExpr, stack.back().state), std::move(pushitem), NonTerminal::BitXorExpr);
                        }
                        break;
                    case TokenType::PIPE:
                        shift(p, lasttok, lookahead, stack, steps, 136); break;
                }
                break;
            case 176:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 137); break;
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BitOrExpr, stack.back().state), std::move(pushitem), NonTerminal::BitOrExpr);
                        }
                        break;
                }
                break;
            case 177:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BitAndExpr, stack.back().state), std::move(pushitem), NonTerminal::BitAndExpr);
                        }
                        break;
                    case TokenType::DOUBLEGREATER:
                        shift(p, lasttok, lookahead, stack, steps, 138); break;
                    case TokenType::DOUBLELESS:
                        shift(p, lasttok, lookahead, stack, steps, 139); break;
                }
                break;
            case 178:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BitShiftExpr, stack.back().state), std::move(pushitem), NonTerminal::BitShiftExpr);
                        }
                        break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 141); break;
                    case TokenType::PLUS:
                        shift(p, lasttok, lookahead, stack, steps, 140); break;
                }
                break;
            case 179:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BitShiftExpr, stack.back().state), std::move(pushitem), NonTerminal::BitShiftExpr);
                        }
                        break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 141); break;
                    case TokenType::PLUS:
                        shift(p, lasttok, lookahead, stack, steps, 140); break;
                }
                break;
            case 180:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::AdditionExpr, stack.back().state), std::move(pushitem), NonTerminal::AdditionExpr);
                        }
                        break;
                    case TokenType::PERCENT:
                        shift(p, lasttok, lookahead, stack, steps, 144); break;
                    case TokenType::SLASH:
                        shift(p, lasttok, lookahead, stack, steps, 143); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 142); break;
                }
                break;
            case 181:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::AdditionExpr, stack.back().state), std::move(pushitem), NonTerminal::AdditionExpr);
                        }
                        break;
                    case TokenType::PERCENT:
                        shift(p, lasttok, lookahead, stack, steps, 144); break;
                    case TokenType::SLASH:
                        shift(p, lasttok, lookahead, stack, steps, 143); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 142); break;
                }
                break;
            case 182:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::MultExpr, stack.back().state), std::move(pushitem), NonTerminal::MultExpr);
                        }
                        break;
                }
                break;
            case 183:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::MultExpr, stack.back().state), std::move(pushitem), NonTerminal::MultExpr);
                        }
                        break;
                }
                break;
            case 184:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
std::unique_ptr<ASTNS::BinaryExpr> push (std::make_unique<ASTNS::BinaryExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::MultExpr, stack.back().state), std::move(pushitem), NonTerminal::MultExpr);
                        }
                        break;
                }
                break;
            case 185:
                switch (lookahead.type) {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 202); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "type cast expression")  });
                }
                break;
            case 186:
                switch (lookahead.type) {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 203); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "function call expression")  });
                }
                break;
            case 187:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::ArgList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::ArgList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ArgList_OPT, stack.back().state), std::move(pushitem), NonTerminal::ArgList_OPT);
                        }
                        break;
                }
                break;
            case 188:
                switch (lookahead.type) {
                    case TokenType::COMMA:
                        shift(p, lasttok, lookahead, stack, steps, 204); break;
                    default: {
                            auto a0 (popA<ASTNS::ArgList>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::ArgList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ArgList, stack.back().state), std::move(pushitem), NonTerminal::ArgList);
                        }
                        break;
                }
                break;
            case 189:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Arg>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
std::unique_ptr<ASTNS::ArgList> push(std::make_unique<ASTNS::ArgList>(p.sourcefile, start, end, std::vector<std::unique_ptr<ASTNS::Arg>> {}));

        push->args.push_back(std::move(a0));
                            std::unique_ptr<ASTNS::ArgList> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::ArgSegment, stack.back().state), std::move(pushitem), NonTerminal::ArgSegment);
                        }
                        break;
                }
                break;
            case 190:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
std::unique_ptr<ASTNS::Arg> push (std::make_unique<ASTNS::Arg>(p.sourcefile, start, end, std::move(a0)));
                            std::unique_ptr<ASTNS::Arg> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::Arg, stack.back().state), std::move(pushitem), NonTerminal::Arg);
                        }
                        break;
                }
                break;
            case 191:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a2;
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a1);
                            stack.emplace_back(getGoto(NonTerminal::PrimaryExpr, stack.back().state), std::move(pushitem), NonTerminal::PrimaryExpr);
                        }
                        break;
                }
                break;
            case 192:
                switch (lookahead.type) {
                    default: {
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::ImplRet>(stack));
                            auto a2 (popA<ASTNS::StmtList>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a4;
std::unique_ptr<ASTNS::Block> push (std::make_unique<ASTNS::Block>(p.sourcefile, start, end, std::move(a2), std::move(a3)));
                            std::unique_ptr<ASTNS::Block> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::IndentedBlock, stack.back().state), std::move(pushitem), NonTerminal::IndentedBlock);
                        }
                        break;
                }
                break;
            case 193:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::PureLocation>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a2) end = a2->end();
                            else if (a1) end = a1->end();
                            else end = a0;
std::unique_ptr<ASTNS::ImplRet> push (std::make_unique<ASTNS::ImplRet>(p.sourcefile, start, end, std::move(a1)));
                            std::unique_ptr<ASTNS::ImplRet> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::ImplRet, stack.back().state), std::move(pushitem), NonTerminal::ImplRet);
                        }
                        break;
                }
                break;
            case 194:
                switch (lookahead.type) {
                    default: {
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::ImplRet>(stack));
                            auto a2 (popA<ASTNS::StmtList>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a4;
std::unique_ptr<ASTNS::Block> push (std::make_unique<ASTNS::Block>(p.sourcefile, start, end, std::move(a2), std::move(a3)));
                            std::unique_ptr<ASTNS::Block> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BracedBlock, stack.back().state), std::move(pushitem), NonTerminal::BracedBlock);
                        }
                        break;
                }
                break;
            case 195:
                switch (lookahead.type) {
                    case TokenType::DEDENT:
                        shift(p, lasttok, lookahead, stack, steps, 205); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::DEDENT), "braced code block")  });
                }
                break;
            case 196:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::VarStmtItem>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::VarStmtItemList>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
a0->items.push_back(std::move(a2));
                            std::unique_ptr<ASTNS::VarStmtItemList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::VarStmtItemSegment, stack.back().state), std::move(pushitem), NonTerminal::VarStmtItemSegment);
                        }
                        break;
                }
                break;
            case 197:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::VarStmtItem>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::VarStmtItem> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::AnotherVarStmtItem, stack.back().state), std::move(pushitem), NonTerminal::AnotherVarStmtItem);
                        }
                        break;
                }
                break;
            case 198:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "variable statement initialization")  });
                }
                break;
            case 199:
                switch (lookahead.type) {
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 166); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "code block", "if expression"), "if expression")  });
                }
                break;
            case 200:
                switch (lookahead.type) {
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 209); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::SEMICOLON), "for expression")  });
                }
                break;
            case 201:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::Expr_OPT, stack.back().state), std::move(pushitem), NonTerminal::Expr_OPT);
                        }
                        break;
                }
                break;
            case 202:
                switch (lookahead.type) {
                    default: {
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Type>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            end = a3;
std::unique_ptr<ASTNS::CastExpr> push (std::make_unique<ASTNS::CastExpr>(p.sourcefile, start, end, std::move(a0), std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CastExpr, stack.back().state), std::move(pushitem), NonTerminal::CastExpr);
                        }
                        break;
                }
                break;
            case 203:
                switch (lookahead.type) {
                    default: {
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::ArgList>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Expr>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            end = a3;
std::unique_ptr<ASTNS::CallExpr> push (std::make_unique<ASTNS::CallExpr>(p.sourcefile, start, end, std::move(a0), a1, std::move(a2)));
                            std::unique_ptr<ASTNS::Expr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::CallExpr, stack.back().state), std::move(pushitem), NonTerminal::CallExpr);
                        }
                        break;
                }
                break;
            case 204:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    default: {
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ArgList>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            end = a1;
                            std::unique_ptr<ASTNS::ArgList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ArgList, stack.back().state), std::move(pushitem), NonTerminal::ArgList);
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                }
                break;
            case 205:
                switch (lookahead.type) {
                    case TokenType::CCURB:
                        shift(p, lasttok, lookahead, stack, steps, 212); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CCURB), "braced code block")  });
                }
                break;
            case 206:
                switch (lookahead.type) {
                    default: {
                            auto a3 (popA<ASTNS::Expr>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a3) end = a3->end();
                            else end = a2;
std::unique_ptr<ASTNS::VarStmtItem> push (std::make_unique<ASTNS::VarStmtItem>(p.sourcefile, start, end, std::move(a1), a0, a2, std::move(a3)));
                            std::unique_ptr<ASTNS::VarStmtItem> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::VarStmtItem, stack.back().state), std::move(pushitem), NonTerminal::VarStmtItem);
                        }
                        break;
                }
                break;
            case 207:
                switch (lookahead.type) {
                    default: {
                            auto a4 (popA<ASTNS::Block>(stack));
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::Block>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a4) end = a4->end();
                            else end = a3;
std::unique_ptr<ASTNS::IfExpr> push (std::make_unique<ASTNS::IfExpr>(p.sourcefile, start, end, a0, std::move(a1), std::move(a2), std::move(a4)));
                            std::unique_ptr<ASTNS::IfExpr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::IfExpr, stack.back().state), std::move(pushitem), NonTerminal::IfExpr);
                        }
                        break;
                }
                break;
            case 208:
                switch (lookahead.type) {
                    default: {
                            auto a4 (popA<ASTNS::IfExpr>(stack));
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::Block>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a4) end = a4->end();
                            else end = a3;
std::unique_ptr<ASTNS::IfExpr> push (std::make_unique<ASTNS::IfExpr>(p.sourcefile, start, end, a0, std::move(a1), std::move(a2), std::move(a4)));
                            std::unique_ptr<ASTNS::IfExpr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::IfExpr, stack.back().state), std::move(pushitem), NonTerminal::IfExpr);
                        }
                        break;
                }
                break;
            case 209:
                switch (lookahead.type) {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 99); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 25); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 101); break;
                    case TokenType::CPARN:
                    case TokenType::SEMICOLON:
{
                            std::unique_ptr<ASTNS::Expr> pushitem = nullptr;
                            stack.emplace_back(getGoto(NonTerminal::Expr_OPT, stack.back().state), std::move(pushitem), NonTerminal::Expr_OPT);
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 97); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 94); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 95); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 73); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 100); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 103); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 72); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 104); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 102); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 93); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 26); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "optional expression", "for expression")  });
                }
                break;
            case 210:
                switch (lookahead.type) {
                    default: {
                            auto a2 (popA<ASTNS::Arg>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ArgList>(stack));
                            Location start, end;
                            if (a0) start = a0->start();
                            else start = a1;
                            if (a2) end = a2->end();
                            else end = a1;
a0->args.push_back(std::move(a2));
                            std::unique_ptr<ASTNS::ArgList> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::ArgSegment, stack.back().state), std::move(pushitem), NonTerminal::ArgSegment);
                        }
                        break;
                }
                break;
            case 211:
                switch (lookahead.type) {
                    default: {
                            auto a0 (popA<ASTNS::Arg>(stack));
                            Location start ((a0.get())), end ((a0.get()));
                            if (a0) start = a0->start();
                            if (a0) end = a0->end();
                            std::unique_ptr<ASTNS::Arg> pushitem = std::move(a0);
                            stack.emplace_back(getGoto(NonTerminal::AnotherArg, stack.back().state), std::move(pushitem), NonTerminal::AnotherArg);
                        }
                        break;
                }
                break;
            case 212:
                switch (lookahead.type) {
                    default: {
                            auto a6 (popT(stack));
                            auto a5 (popT(stack));
                            auto a4 (popA<ASTNS::ImplRet>(stack));
                            auto a3 (popA<ASTNS::StmtList>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            end = a6;
std::unique_ptr<ASTNS::Block> push (std::make_unique<ASTNS::Block>(p.sourcefile, start, end, std::move(a3), std::move(a4)));
                            std::unique_ptr<ASTNS::Block> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::BracedBlock, stack.back().state), std::move(pushitem), NonTerminal::BracedBlock);
                        }
                        break;
                }
                break;
            case 213:
                switch (lookahead.type) {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 214); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "for expression")  });
                }
                break;
            case 214:
                switch (lookahead.type) {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 166); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 52); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "code block", "for expression")  });
                }
                break;
            case 215:
                switch (lookahead.type) {
                    default: {
                            auto a7 (popA<ASTNS::Block>(stack));
                            auto a6 (popT(stack));
                            auto a5 (popA<ASTNS::Expr>(stack));
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::Expr>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::VarStmt>(stack));
                            auto a0 (popT(stack));
                            Location start, end;
                            start = a0;
                            if (a7) end = a7->end();
                            else end = a6;
std::unique_ptr<ASTNS::ForExpr> push (std::make_unique<ASTNS::ForExpr>(p.sourcefile, start, end, std::move(a1), std::move(a3), std::move(a5), std::move(a7)));
                            std::unique_ptr<ASTNS::ForExpr> pushitem = std::move(push);
                            stack.emplace_back(getGoto(NonTerminal::ForExpr, stack.back().state), std::move(pushitem), NonTerminal::ForExpr);
                        }
                        break;
                }
                break;
            default:
                reportAbortNoh(format("Parser reached invalid state: %", stack.back().state));
        }
    }
// This code was autogenerated - see the utils/ directory
    // PARSERLOOP END
    // }}}

    if (istrial)
        return true;

    if (errored) {
        p.errored = true;
        out = nullptr;
        return false;
    }

    stackitem topsi (std::move(stack.back()));
    ASSERT(std::holds_alternative<astitem>(topsi.item))

    astitem &ai = std::get<astitem>(topsi.item);
    std::unique_ptr<ASTNS::AST> astu (std::move(ai.ast));
    ASTNS::CUB *cub = static_cast<ASTNS::CUB*>(astu.get());
    astu.release();
    out = std::unique_ptr<ASTNS::CUB>(cub);
    return true;
}
