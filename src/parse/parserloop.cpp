#include "parse/parser.h"
#include "parsestack.h" // in a private header file
#include <vector>
#include "utils/format.h"
#include "utils/assert.h"

// get goto {{{
// GETGOTO START

// The following code was autogenerated - see the utils/ directory
template <> size_t getGoto<ASTNS::CU>(size_t state)
{
    switch (state)
    {
        case 0:
            return 1;
        default:
            reportAbortNoh("retrieve goto of nonterminal CU in invalid state");
    }
}
template <> size_t getGoto<ASTNS::AnotherParam>(size_t state)
{
    switch (state)
    {
        case 31:
            return 40;
        default:
            reportAbortNoh("retrieve goto of nonterminal AnotherParam in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Param>(size_t state)
{
    switch (state)
    {
        case 24:
            return 28;
        case 31:
            return 41;
        default:
            reportAbortNoh("retrieve goto of nonterminal Param in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ParamSegment>(size_t state)
{
    switch (state)
    {
        case 24:
            return 27;
        default:
            reportAbortNoh("retrieve goto of nonterminal ParamSegment in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ParamList>(size_t state)
{
    switch (state)
    {
        case 24:
            return 26;
        default:
            reportAbortNoh("retrieve goto of nonterminal ParamList in invalid state");
    }
}
template <> size_t getGoto<ASTNS::AnotherArg>(size_t state)
{
    switch (state)
    {
        case 188:
            return 196;
        default:
            reportAbortNoh("retrieve goto of nonterminal AnotherArg in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Arg>(size_t state)
{
    switch (state)
    {
        case 136:
            return 174;
        case 188:
            return 197;
        default:
            reportAbortNoh("retrieve goto of nonterminal Arg in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ArgSegment>(size_t state)
{
    switch (state)
    {
        case 136:
            return 173;
        default:
            reportAbortNoh("retrieve goto of nonterminal ArgSegment in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ArgList>(size_t state)
{
    switch (state)
    {
        case 136:
            return 172;
        default:
            reportAbortNoh("retrieve goto of nonterminal ArgList in invalid state");
    }
}
template <> size_t getGoto<ASTNS::AnotherVarStmtItem>(size_t state)
{
    switch (state)
    {
        case 181:
            return 190;
        default:
            reportAbortNoh("retrieve goto of nonterminal AnotherVarStmtItem in invalid state");
    }
}
template <> size_t getGoto<ASTNS::VarStmtItem>(size_t state)
{
    switch (state)
    {
        case 101:
            return 144;
        case 181:
            return 191;
        default:
            reportAbortNoh("retrieve goto of nonterminal VarStmtItem in invalid state");
    }
}
template <> size_t getGoto<ASTNS::VarStmtItemSegment>(size_t state)
{
    switch (state)
    {
        case 101:
            return 143;
        default:
            reportAbortNoh("retrieve goto of nonterminal VarStmtItemSegment in invalid state");
    }
}
template <> size_t getGoto<ASTNS::VarStmtItemList>(size_t state)
{
    switch (state)
    {
        case 101:
            return 142;
        default:
            reportAbortNoh("retrieve goto of nonterminal VarStmtItemList in invalid state");
    }
}
template <> size_t getGoto<ASTNS::AnotherStmt>(size_t state)
{
    switch (state)
    {
        case 49:
            return 99;
        default:
            reportAbortNoh("retrieve goto of nonterminal AnotherStmt in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Stmt>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 98:
            return 50;
        case 49:
            return 100;
        default:
            reportAbortNoh("retrieve goto of nonterminal Stmt in invalid state");
    }
}
template <> size_t getGoto<ASTNS::StmtList>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 98:
            return 49;
        default:
            reportAbortNoh("retrieve goto of nonterminal StmtList in invalid state");
    }
}
template <> size_t getGoto<ASTNS::AnotherDecl>(size_t state)
{
    switch (state)
    {
        case 2:
            return 6;
        default:
            reportAbortNoh("retrieve goto of nonterminal AnotherDecl in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Decl>(size_t state)
{
    switch (state)
    {
        case 0:
            return 3;
        case 2:
            return 7;
        default:
            reportAbortNoh("retrieve goto of nonterminal Decl in invalid state");
    }
}
template <> size_t getGoto<ASTNS::DeclList>(size_t state)
{
    switch (state)
    {
        case 0:
            return 2;
        default:
            reportAbortNoh("retrieve goto of nonterminal DeclList in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ParamList_OPT>(size_t state)
{
    switch (state)
    {
        case 24:
            return 25;
        default:
            reportAbortNoh("retrieve goto of nonterminal ParamList_OPT in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ArgList_OPT>(size_t state)
{
    switch (state)
    {
        case 136:
            return 171;
        default:
            reportAbortNoh("retrieve goto of nonterminal ArgList_OPT in invalid state");
    }
}
template <> size_t getGoto<ASTNS::StmtList_OPT>(size_t state)
{
    switch (state)
    {
        case 39:
            return 47;
        case 45:
            return 93;
        case 48:
            return 97;
        case 98:
            return 141;
        default:
            reportAbortNoh("retrieve goto of nonterminal StmtList_OPT in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ImplRet_OPT>(size_t state)
{
    switch (state)
    {
        case 47:
            return 94;
        case 93:
            return 137;
        case 97:
            return 140;
        case 141:
            return 179;
        default:
            reportAbortNoh("retrieve goto of nonterminal ImplRet_OPT in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ImplRet>(size_t state)
{
    switch (state)
    {
        case 47:
        case 93:
        case 97:
        case 141:
            return 95;
        default:
            reportAbortNoh("retrieve goto of nonterminal ImplRet in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Expr_OPT>(size_t state)
{
    switch (state)
    {
        case 151:
            return 184;
        case 195:
            return 199;
        default:
            reportAbortNoh("retrieve goto of nonterminal Expr_OPT in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Expr>(size_t state)
{
    switch (state)
    {
        case 57:
            return 104;
        case 63:
            return 110;
        case 75:
        case 133:
            return 131;
        case 96:
            return 139;
        case 136:
        case 188:
            return 175;
        case 151:
        case 195:
            return 185;
        case 182:
            return 192;
        default:
            reportAbortNoh("retrieve goto of nonterminal Expr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::VarStmt_OPT>(size_t state)
{
    switch (state)
    {
        case 64:
            return 111;
        default:
            reportAbortNoh("retrieve goto of nonterminal VarStmt_OPT in invalid state");
    }
}
template <> size_t getGoto<ASTNS::VarStmt>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 98:
            return 51;
        case 64:
            return 112;
        default:
            reportAbortNoh("retrieve goto of nonterminal VarStmt in invalid state");
    }
}
template <> size_t getGoto<ASTNS::LineEnding_OPT>(size_t state)
{
    switch (state)
    {
        case 33:
            return 42;
        case 56:
            return 103;
        case 139:
            return 177;
        default:
            reportAbortNoh("retrieve goto of nonterminal LineEnding_OPT in invalid state");
    }
}
template <> size_t getGoto<ASTNS::LineEnding>(size_t state)
{
    switch (state)
    {
        case 30:
            return 34;
        case 33:
        case 56:
        case 139:
            return 43;
        case 55:
            return 102;
        case 57:
            return 105;
        case 104:
            return 146;
        case 142:
            return 180;
        default:
            reportAbortNoh("retrieve goto of nonterminal LineEnding in invalid state");
    }
}
template <> size_t getGoto<ASTNS::FunctionDecl>(size_t state)
{
    switch (state)
    {
        case 0:
        case 2:
            return 4;
        default:
            reportAbortNoh("retrieve goto of nonterminal FunctionDecl in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Type>(size_t state)
{
    switch (state)
    {
        case 5:
            return 8;
        case 24:
        case 31:
            return 29;
        case 54:
            return 101;
        case 75:
            return 130;
        default:
            reportAbortNoh("retrieve goto of nonterminal Type in invalid state");
    }
}
template <> size_t getGoto<ASTNS::Block>(size_t state)
{
    switch (state)
    {
        case 30:
            return 33;
        case 110:
            return 149;
        case 183:
            return 193;
        case 200:
            return 201;
        default:
            reportAbortNoh("retrieve goto of nonterminal Block in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ExprStmt>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 98:
            return 52;
        default:
            reportAbortNoh("retrieve goto of nonterminal ExprStmt in invalid state");
    }
}
template <> size_t getGoto<ASTNS::RetStmt>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 98:
            return 53;
        default:
            reportAbortNoh("retrieve goto of nonterminal RetStmt in invalid state");
    }
}
template <> size_t getGoto<ASTNS::NotBlockedExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 98:
            return 55;
        case 57:
        case 63:
        case 75:
        case 96:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 107;
        default:
            reportAbortNoh("retrieve goto of nonterminal NotBlockedExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BlockedExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 98:
            return 56;
        case 57:
        case 63:
        case 75:
        case 96:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 106;
        default:
            reportAbortNoh("retrieve goto of nonterminal BlockedExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BracedBlock>(size_t state)
{
    switch (state)
    {
        case 30:
        case 110:
        case 183:
        case 200:
            return 35;
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 61;
        default:
            reportAbortNoh("retrieve goto of nonterminal BracedBlock in invalid state");
    }
}
template <> size_t getGoto<ASTNS::IndentedBlock>(size_t state)
{
    switch (state)
    {
        case 30:
        case 110:
        case 183:
        case 200:
            return 36;
        default:
            reportAbortNoh("retrieve goto of nonterminal IndentedBlock in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BuiltinType>(size_t state)
{
    switch (state)
    {
        case 5:
        case 24:
        case 31:
        case 54:
        case 75:
            return 9;
        default:
            reportAbortNoh("retrieve goto of nonterminal BuiltinType in invalid state");
    }
}
template <> size_t getGoto<ASTNS::AssignmentExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 58;
        case 108:
            return 147;
        default:
            reportAbortNoh("retrieve goto of nonterminal AssignmentExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::IfExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 59;
        case 183:
            return 194;
        default:
            reportAbortNoh("retrieve goto of nonterminal IfExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::ForExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 60;
        default:
            reportAbortNoh("retrieve goto of nonterminal ForExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BinOrExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 62;
        default:
            reportAbortNoh("retrieve goto of nonterminal BinOrExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BinAndExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 65;
        case 109:
            return 148;
        default:
            reportAbortNoh("retrieve goto of nonterminal BinAndExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::CompEQExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 66;
        case 113:
            return 152;
        default:
            reportAbortNoh("retrieve goto of nonterminal CompEQExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::CompLGTExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 67;
        case 114:
            return 153;
        case 115:
            return 154;
        default:
            reportAbortNoh("retrieve goto of nonterminal CompLGTExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BitXorExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 68;
        case 116:
            return 155;
        case 117:
            return 156;
        case 118:
            return 157;
        case 119:
            return 158;
        default:
            reportAbortNoh("retrieve goto of nonterminal BitXorExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BitOrExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 69;
        case 120:
            return 159;
        default:
            reportAbortNoh("retrieve goto of nonterminal BitOrExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BitAndExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 70;
        case 121:
            return 160;
        default:
            reportAbortNoh("retrieve goto of nonterminal BitAndExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::BitShiftExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 71;
        case 122:
            return 161;
        default:
            reportAbortNoh("retrieve goto of nonterminal BitShiftExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::AdditionExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 72;
        case 123:
            return 162;
        case 124:
            return 163;
        default:
            reportAbortNoh("retrieve goto of nonterminal AdditionExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::MultExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 73;
        case 125:
            return 164;
        case 126:
            return 165;
        default:
            reportAbortNoh("retrieve goto of nonterminal MultExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::UnaryExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 133:
        case 136:
        case 151:
        case 169:
        case 182:
        case 188:
        case 195:
            return 76;
        case 77:
            return 132;
        case 78:
            return 134;
        case 79:
            return 135;
        case 127:
            return 166;
        case 128:
            return 167;
        case 129:
            return 168;
        default:
            reportAbortNoh("retrieve goto of nonterminal UnaryExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::CastExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 133:
        case 136:
        case 151:
        case 182:
        case 188:
        case 195:
            return 74;
        case 169:
            return 186;
        default:
            reportAbortNoh("retrieve goto of nonterminal CastExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::CallExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 77:
        case 78:
        case 79:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case 128:
        case 129:
        case 133:
        case 136:
        case 151:
        case 169:
        case 182:
        case 188:
        case 195:
            return 80;
        default:
            reportAbortNoh("retrieve goto of nonterminal CallExpr in invalid state");
    }
}
template <> size_t getGoto<ASTNS::PrimaryExpr>(size_t state)
{
    switch (state)
    {
        case 39:
        case 45:
        case 48:
        case 49:
        case 57:
        case 63:
        case 75:
        case 77:
        case 78:
        case 79:
        case 96:
        case 98:
        case 108:
        case 109:
        case 113:
        case 114:
        case 115:
        case 116:
        case 117:
        case 118:
        case 119:
        case 120:
        case 121:
        case 122:
        case 123:
        case 124:
        case 125:
        case 126:
        case 127:
        case 128:
        case 129:
        case 133:
        case 136:
        case 151:
        case 169:
        case 182:
        case 188:
        case 195:
            return 81;
        default:
            reportAbortNoh("retrieve goto of nonterminal PrimaryExpr in invalid state");
    }
}
// This code was autogenerated - see the utils/ directory

// GETGOTO END
// }}}

static void shift(Parser &p, Token &last, Token &lookahead, std::vector<stackitem> &stack, int &steps, int const &newst)
{
    last = lookahead;
    stack.emplace_back(newst, last);
    lookahead = p.consume();
    ++steps;
}

static Token popT(std::vector<stackitem> &stack)
{
    stackitem si = std::move(stack.back());

    stack.pop_back();
    return si.tok;
}

template <typename A>
static std::unique_ptr<A> popA(std::vector<stackitem> &stack)
{
    stackitem si = std::move(stack.back());
    stack.pop_back();

    A *astraw = static_cast<A*>(si.ast.release());
    return std::unique_ptr<A>(astraw);
}

template <typename A>
static void reduceSkip(std::vector<stackitem> &stack)
{
    size_t newstate = getGoto<A>((stack.end() - 2)->state);
    stack.back().state = newstate;
}

static void error(bool &done, bool &errored, errorstate const &ers, std::vector<std::string> const &expectations)
{
    errored = true;

    if (!errorRecovery(ers, expectations))
        done = true;
}

bool _parse(Parser &p, std::vector<stackitem> &stack, bool istrial, std::unique_ptr<ASTNS::CUB> &out, Token const &_lookahead)
{
    // parser loop {{{
    // PARSERLOOP START

// The following code was autogenerated - see the utils/ directory
    bool done = false;
    bool errored = false;
    int steps = 0;
    Token lookahead (_lookahead); // for when you need to inject a new token
    Token lasttok = lookahead;
    while (!done)
    {
        if (istrial && steps > 5)
            return true;
        switch (stack.back().state)
        {
            case 0:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CU>());
                            stack.emplace_back(getGoto<ASTNS::CU>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::FUN:
                        shift(p, lasttok, lookahead, stack, steps, 5); break;
                }
                break;
            case 1:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                            done = true;
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % to terminate %", stringifyTokenType(TokenType::EOF_), "")  });
                }
                break;
            case 2:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popA<ASTNS::DeclList>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CU>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::CU>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::FUN:
                        shift(p, lasttok, lookahead, stack, steps, 5); break;
                }
                break;
            case 3:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::DeclList>(stack);
                        break;
                }
                break;
            case 4:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Decl>(stack);
                        break;
                }
                break;
            case 5:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 11); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 12); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 13); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 10); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "type specifier", "function declaration")  });
                }
                break;
            case 6:
               switch (lookahead.type)
               {
                    case TokenType::EOF_:
                    case TokenType::FUN:
                        {
                            auto a1 (popA<ASTNS::AnotherDecl>(stack));
                            auto a0 (popA<ASTNS::DeclList>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::DeclList>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::DeclList>(stack.back().state), std::move(push));
                        }
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % to terminate %", format("either % or %", stringifyTokenType(TokenType::FUN), stringifyTokenType(TokenType::EOF_)), "declaration list")  });
                }
                break;
            case 7:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::AnotherDecl>(stack);
                        break;
                }
                break;
            case 8:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 23); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::IDENTIFIER), "function declaration")  });
                }
                break;
            case 9:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Type>(stack);
                        break;
                }
                break;
            case 10:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 11:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 12:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 13:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 14:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 15:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 16:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 17:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 18:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 19:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 20:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 21:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 22:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BuiltinType>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::BuiltinType>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 23:
               switch (lookahead.type)
               {
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 24); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::OPARN), "function declaration")  });
                }
                break;
            case 24:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ParamList_OPT>());
                            stack.emplace_back(getGoto<ASTNS::ParamList_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 11); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 12); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 13); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 10); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                }
                break;
            case 25:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 30); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "function declaration")  });
                }
                break;
            case 26:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::ParamList_OPT>(stack);
                        break;
                }
                break;
            case 27:
               switch (lookahead.type)
               {
                    case TokenType::COMMA:
                        shift(p, lasttok, lookahead, stack, steps, 31); break;
                    case TokenType::CPARN:
                        reduceSkip<ASTNS::ParamList>(stack);
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::COMMA), "parameter list"), format("expected % for %", stringifyTokenType(TokenType::COMMA), "parameter list"), format("expected % to terminate %", stringifyTokenType(TokenType::CPARN), "parameter list")  });
                }
                break;
            case 28:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::ParamSegment>(stack);
                        break;
                }
                break;
            case 29:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 32); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::IDENTIFIER), "parameter")  });
                }
                break;
            case 30:
               switch (lookahead.type)
               {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 37); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "code block", "line ending"), "function declaration")  });
                }
                break;
            case 31:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::CPARN:
                        {
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ParamSegment>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ParamList>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::ParamList>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 11); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 12); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 13); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 10); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "another parameter", "parameter list"), format("expected % to terminate %", stringifyTokenType(TokenType::CPARN), "parameter list")  });
                }
                break;
            case 32:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::Type>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::Param>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::Param>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 33:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::LineEnding_OPT>());
                            stack.emplace_back(getGoto<ASTNS::LineEnding_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 44); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                }
                break;
            case 34:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a6 (popA<ASTNS::LineEnding>(stack));
                            auto a5 (popT(stack));
                            auto a4 (popA<ASTNS::ParamList_OPT>(stack));
                            auto a3 (popT(stack));
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::FunctionDecl>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4), std::move(a5), std::move(a6)));
                            stack.emplace_back(getGoto<ASTNS::FunctionDecl>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 35:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Block>(stack);
                        break;
                }
                break;
            case 36:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Block>(stack);
                        break;
                }
                break;
            case 37:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::LineEnding>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::LineEnding>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::INDENT:
                        shift(p, lasttok, lookahead, stack, steps, 45); break;
                }
                break;
            case 38:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::LineEnding>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::LineEnding>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 46); break;
                }
                break;
            case 39:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::StmtList_OPT>());
                            stack.emplace_back(getGoto<ASTNS::StmtList_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 48); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 57); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 54); break;
                }
                break;
            case 40:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::AnotherParam>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ParamSegment>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ParamSegment>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::ParamSegment>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 41:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::AnotherParam>(stack);
                        break;
                }
                break;
            case 42:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a7 (popA<ASTNS::LineEnding_OPT>(stack));
                            auto a6 (popA<ASTNS::Block>(stack));
                            auto a5 (popT(stack));
                            auto a4 (popA<ASTNS::ParamList_OPT>(stack));
                            auto a3 (popT(stack));
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::FunctionDecl>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4), std::move(a5), std::move(a6), std::move(a7)));
                            stack.emplace_back(getGoto<ASTNS::FunctionDecl>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 43:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::LineEnding_OPT>(stack);
                        break;
                }
                break;
            case 44:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::LineEnding>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::LineEnding>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 45:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::StmtList_OPT>());
                            stack.emplace_back(getGoto<ASTNS::StmtList_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 57); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 54); break;
                }
                break;
            case 46:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::LineEnding>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::LineEnding>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 47:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ImplRet_OPT>());
                            stack.emplace_back(getGoto<ASTNS::ImplRet_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                }
                break;
            case 48:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::StmtList_OPT>());
                            stack.emplace_back(getGoto<ASTNS::StmtList_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::INDENT:
                        shift(p, lasttok, lookahead, stack, steps, 98); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 57); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 54); break;
                }
                break;
            case 49:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    default:
                        reduceSkip<ASTNS::StmtList_OPT>(stack);
                        break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 57); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 54); break;
                }
                break;
            case 50:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::StmtList>(stack);
                        break;
                }
                break;
            case 51:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Stmt>(stack);
                        break;
                }
                break;
            case 52:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Stmt>(stack);
                        break;
                }
                break;
            case 53:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Stmt>(stack);
                        break;
                }
                break;
            case 54:
               switch (lookahead.type)
               {
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 11); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 12); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 13); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 10); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "type specifier", "variable statement")  });
                }
                break;
            case 55:
               switch (lookahead.type)
               {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 44); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "line ending", "expression statement")  });
                }
                break;
            case 56:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::LineEnding_OPT>());
                            stack.emplace_back(getGoto<ASTNS::LineEnding_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 44); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                }
                break;
            case 57:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 44); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "expression", "line ending"), "return statement")  });
                }
                break;
            case 58:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::NotBlockedExpr>(stack);
                        break;
                }
                break;
            case 59:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::BlockedExpr>(stack);
                        break;
                }
                break;
            case 60:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::BlockedExpr>(stack);
                        break;
                }
                break;
            case 61:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::BlockedExpr>(stack);
                        break;
                }
                break;
            case 62:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::AssignmentExpr>(stack);
                        break;
                    case TokenType::DOUBLEPIPE:
                        shift(p, lasttok, lookahead, stack, steps, 109); break;
                    case TokenType::EQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 108); break;
                }
                break;
            case 63:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "if expression")  });
                }
                break;
            case 64:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::VarStmt_OPT>());
                            stack.emplace_back(getGoto<ASTNS::VarStmt_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 54); break;
                }
                break;
            case 65:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::BinOrExpr>(stack);
                        break;
                    case TokenType::DOUBLEAMPER:
                        shift(p, lasttok, lookahead, stack, steps, 113); break;
                }
                break;
            case 66:
               switch (lookahead.type)
               {
                    case TokenType::BANGEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 114); break;
                    default:
                        reduceSkip<ASTNS::BinAndExpr>(stack);
                        break;
                    case TokenType::DOUBLEEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 115); break;
                }
                break;
            case 67:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::CompEQExpr>(stack);
                        break;
                    case TokenType::GREATER:
                        shift(p, lasttok, lookahead, stack, steps, 117); break;
                    case TokenType::GREATEREQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 119); break;
                    case TokenType::LESS:
                        shift(p, lasttok, lookahead, stack, steps, 116); break;
                    case TokenType::LESSEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 118); break;
                }
                break;
            case 68:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::CompLGTExpr>(stack);
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 120); break;
                }
                break;
            case 69:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::BitXorExpr>(stack);
                        break;
                    case TokenType::PIPE:
                        shift(p, lasttok, lookahead, stack, steps, 121); break;
                }
                break;
            case 70:
               switch (lookahead.type)
               {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 122); break;
                    default:
                        reduceSkip<ASTNS::BitOrExpr>(stack);
                        break;
                }
                break;
            case 71:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::BitAndExpr>(stack);
                        break;
                    case TokenType::DOUBLEGREATER:
                        shift(p, lasttok, lookahead, stack, steps, 123); break;
                    case TokenType::DOUBLELESS:
                        shift(p, lasttok, lookahead, stack, steps, 124); break;
                }
                break;
            case 72:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::BitShiftExpr>(stack);
                        break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 126); break;
                    case TokenType::PLUS:
                        shift(p, lasttok, lookahead, stack, steps, 125); break;
                }
                break;
            case 73:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::AdditionExpr>(stack);
                        break;
                    case TokenType::PERCENT:
                        shift(p, lasttok, lookahead, stack, steps, 129); break;
                    case TokenType::SLASH:
                        shift(p, lasttok, lookahead, stack, steps, 128); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 127); break;
                }
                break;
            case 74:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::MultExpr>(stack);
                        break;
                }
                break;
            case 75:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::BOOL:
                        shift(p, lasttok, lookahead, stack, steps, 19); break;
                    case TokenType::CHAR:
                        shift(p, lasttok, lookahead, stack, steps, 21); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::DOUBLE:
                        shift(p, lasttok, lookahead, stack, steps, 20); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOAT:
                        shift(p, lasttok, lookahead, stack, steps, 18); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::SINT16:
                        shift(p, lasttok, lookahead, stack, steps, 15); break;
                    case TokenType::SINT32:
                        shift(p, lasttok, lookahead, stack, steps, 16); break;
                    case TokenType::SINT64:
                        shift(p, lasttok, lookahead, stack, steps, 17); break;
                    case TokenType::SINT8:
                        shift(p, lasttok, lookahead, stack, steps, 14); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    case TokenType::UINT16:
                        shift(p, lasttok, lookahead, stack, steps, 11); break;
                    case TokenType::UINT32:
                        shift(p, lasttok, lookahead, stack, steps, 12); break;
                    case TokenType::UINT64:
                        shift(p, lasttok, lookahead, stack, steps, 13); break;
                    case TokenType::UINT8:
                        shift(p, lasttok, lookahead, stack, steps, 10); break;
                    case TokenType::VOID:
                        shift(p, lasttok, lookahead, stack, steps, 22); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "type specifier", "type cast expression"), format("expected % for %", "expression", "primary expression")  });
                }
                break;
            case 76:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::CastExpr>(stack);
                        break;
                }
                break;
            case 77:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 78:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 79:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "unary expression")  });
                }
                break;
            case 80:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::UnaryExpr>(stack);
                        break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 136); break;
                }
                break;
            case 81:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::CallExpr>(stack);
                        break;
                }
                break;
            case 82:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 83:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 84:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 85:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 86:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 87:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 88:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 89:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 90:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 91:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 92:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 93:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ImplRet_OPT>());
                            stack.emplace_back(getGoto<ASTNS::ImplRet_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                }
                break;
            case 94:
               switch (lookahead.type)
               {
                    case TokenType::CCURB:
                        shift(p, lasttok, lookahead, stack, steps, 138); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CCURB), "braced code block")  });
                }
                break;
            case 95:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::ImplRet_OPT>(stack);
                        break;
                }
                break;
            case 96:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "implicit return")  });
                }
                break;
            case 97:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ImplRet_OPT>());
                            stack.emplace_back(getGoto<ASTNS::ImplRet_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                }
                break;
            case 98:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::StmtList_OPT>());
                            stack.emplace_back(getGoto<ASTNS::StmtList_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::RETURN:
                        shift(p, lasttok, lookahead, stack, steps, 57); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    case TokenType::VAR:
                        shift(p, lasttok, lookahead, stack, steps, 54); break;
                }
                break;
            case 99:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                    case TokenType::BININTLIT:
                    case TokenType::CCURB:
                    case TokenType::CHARLIT:
                    case TokenType::DECINTLIT:
                    case TokenType::DEDENT:
                    case TokenType::FALSELIT:
                    case TokenType::FLOATLIT:
                    case TokenType::FOR:
                    case TokenType::HEXINTLIT:
                    case TokenType::IDENTIFIER:
                    case TokenType::IF:
                    case TokenType::LEFTARROW:
                    case TokenType::MINUS:
                    case TokenType::NULLPTRLIT:
                    case TokenType::OCTINTLIT:
                    case TokenType::OCURB:
                    case TokenType::OPARN:
                    case TokenType::RETURN:
                    case TokenType::STRINGLIT:
                    case TokenType::TILDE:
                    case TokenType::TRUELIT:
                    case TokenType::VAR:
                        {
                            auto a1 (popA<ASTNS::AnotherStmt>(stack));
                            auto a0 (popA<ASTNS::StmtList>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::StmtList>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::StmtList>(stack.back().state), std::move(push));
                        }
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % to terminate %", format("%, %, %, %, %, %, %, %, %, %, %, %, %, %, %, %, %, %, %, %, %, %, or %", stringifyTokenType(TokenType::VAR), stringifyTokenType(TokenType::RETURN), stringifyTokenType(TokenType::OCURB), stringifyTokenType(TokenType::IF), stringifyTokenType(TokenType::FOR), stringifyTokenType(TokenType::OPARN), stringifyTokenType(TokenType::TILDE), stringifyTokenType(TokenType::MINUS), stringifyTokenType(TokenType::BANG), stringifyTokenType(TokenType::TRUELIT), stringifyTokenType(TokenType::FALSELIT), stringifyTokenType(TokenType::FLOATLIT), stringifyTokenType(TokenType::NULLPTRLIT), stringifyTokenType(TokenType::DECINTLIT), stringifyTokenType(TokenType::OCTINTLIT), stringifyTokenType(TokenType::BININTLIT), stringifyTokenType(TokenType::HEXINTLIT), stringifyTokenType(TokenType::CHARLIT), stringifyTokenType(TokenType::STRINGLIT), stringifyTokenType(TokenType::IDENTIFIER), stringifyTokenType(TokenType::LEFTARROW), stringifyTokenType(TokenType::CCURB), stringifyTokenType(TokenType::DEDENT)), "statement list")  });
                }
                break;
            case 100:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::AnotherStmt>(stack);
                        break;
                }
                break;
            case 101:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 145); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "variable statement initialization list", "variable statement")  });
                }
                break;
            case 102:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popA<ASTNS::LineEnding>(stack));
                            auto a0 (popA<ASTNS::NotBlockedExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ExprStmt>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::ExprStmt>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 103:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popA<ASTNS::LineEnding_OPT>(stack));
                            auto a0 (popA<ASTNS::BlockedExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ExprStmt>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::ExprStmt>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 104:
               switch (lookahead.type)
               {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 44); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "line ending", "return statement")  });
                }
                break;
            case 105:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popA<ASTNS::LineEnding>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::RetStmt>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::RetStmt>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 106:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Expr>(stack);
                        break;
                }
                break;
            case 107:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Expr>(stack);
                        break;
                }
                break;
            case 108:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "assignment expression", "assignment expression")  });
                }
                break;
            case 109:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "binary and expression", "binary or expression")  });
                }
                break;
            case 110:
               switch (lookahead.type)
               {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 150); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "code block", "if expression")  });
                }
                break;
            case 111:
               switch (lookahead.type)
               {
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 151); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::SEMICOLON), "for expression")  });
                }
                break;
            case 112:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::VarStmt_OPT>(stack);
                        break;
                }
                break;
            case 113:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "equality expression", "binary and expression")  });
                }
                break;
            case 114:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "comparison expression", "equality expression")  });
                }
                break;
            case 115:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "comparison expression", "equality expression")  });
                }
                break;
            case 116:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 117:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 118:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 119:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise xor expression", "comparison expression")  });
                }
                break;
            case 120:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise or expression", "bitwise xor expression")  });
                }
                break;
            case 121:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bitwise and expression", "bitwise or expression")  });
                }
                break;
            case 122:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "bit shift expression", "bitwise and expression")  });
                }
                break;
            case 123:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "addition expression", "bit shift expression")  });
                }
                break;
            case 124:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "addition expression", "bit shift expression")  });
                }
                break;
            case 125:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "multiplication expression", "addition expression")  });
                }
                break;
            case 126:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "multiplication expression", "addition expression")  });
                }
                break;
            case 127:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "multiplication expression")  });
                }
                break;
            case 128:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "multiplication expression")  });
                }
                break;
            case 129:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 133); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "unary expression", "multiplication expression")  });
                }
                break;
            case 130:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 169); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "type cast expression")  });
                }
                break;
            case 131:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 170); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "primary expression")  });
                }
                break;
            case 132:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popA<ASTNS::UnaryExpr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::UnaryExpr>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::UnaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 133:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "primary expression")  });
                }
                break;
            case 134:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popA<ASTNS::UnaryExpr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::UnaryExpr>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::UnaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 135:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a1 (popA<ASTNS::UnaryExpr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::UnaryExpr>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::UnaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 136:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ArgList_OPT>());
                            stack.emplace_back(getGoto<ASTNS::ArgList_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                }
                break;
            case 137:
               switch (lookahead.type)
               {
                    case TokenType::DEDENT:
                        shift(p, lasttok, lookahead, stack, steps, 176); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::DEDENT), "indented code block")  });
                }
                break;
            case 138:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::ImplRet_OPT>(stack));
                            auto a1 (popA<ASTNS::StmtList_OPT>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BracedBlock>(std::move(a0), std::move(a1), std::move(a2), std::move(a3)));
                            stack.emplace_back(getGoto<ASTNS::BracedBlock>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 139:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::LineEnding_OPT>());
                            stack.emplace_back(getGoto<ASTNS::LineEnding_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 44); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                }
                break;
            case 140:
               switch (lookahead.type)
               {
                    case TokenType::CCURB:
                        shift(p, lasttok, lookahead, stack, steps, 178); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CCURB), "braced code block")  });
                }
                break;
            case 141:
               switch (lookahead.type)
               {
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ImplRet_OPT>());
                            stack.emplace_back(getGoto<ASTNS::ImplRet_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::LEFTARROW:
                        shift(p, lasttok, lookahead, stack, steps, 96); break;
                }
                break;
            case 142:
               switch (lookahead.type)
               {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 44); break;
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 38); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "line ending", "variable statement")  });
                }
                break;
            case 143:
               switch (lookahead.type)
               {
                    case TokenType::COMMA:
                        shift(p, lasttok, lookahead, stack, steps, 181); break;
                    case TokenType::NEWLINE:
                    case TokenType::SEMICOLON:
                        reduceSkip<ASTNS::VarStmtItemList>(stack);
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::COMMA), "variable statement initialization list"), format("expected % for %", stringifyTokenType(TokenType::COMMA), "variable statement initialization list"), format("expected % to terminate %", format("either % or %", stringifyTokenType(TokenType::NEWLINE), stringifyTokenType(TokenType::SEMICOLON)), "variable statement initialization list")  });
                }
                break;
            case 144:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::VarStmtItemSegment>(stack);
                        break;
                }
                break;
            case 145:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::VarStmtItem>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::VarStmtItem>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::EQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 182); break;
                }
                break;
            case 146:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::LineEnding>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::RetStmt>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::RetStmt>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 147:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::AssignmentExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BinOrExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::AssignmentExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::AssignmentExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 148:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::BinAndExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BinOrExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BinOrExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::BinOrExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DOUBLEAMPER:
                        shift(p, lasttok, lookahead, stack, steps, 113); break;
                }
                break;
            case 149:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::Block>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::IfExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::IfExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::ELSE:
                        shift(p, lasttok, lookahead, stack, steps, 183); break;
                }
                break;
            case 150:
               switch (lookahead.type)
               {
                    case TokenType::INDENT:
                        shift(p, lasttok, lookahead, stack, steps, 45); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::INDENT), "indented code block")  });
                }
                break;
            case 151:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::Expr_OPT>());
                            stack.emplace_back(getGoto<ASTNS::Expr_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                }
                break;
            case 152:
               switch (lookahead.type)
               {
                    case TokenType::BANGEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 114); break;
                    default:
                        {
                            auto a2 (popA<ASTNS::CompEQExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BinAndExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BinAndExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::BinAndExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DOUBLEEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 115); break;
                }
                break;
            case 153:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::CompLGTExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::CompEQExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CompEQExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::CompEQExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::GREATER:
                        shift(p, lasttok, lookahead, stack, steps, 117); break;
                    case TokenType::GREATEREQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 119); break;
                    case TokenType::LESS:
                        shift(p, lasttok, lookahead, stack, steps, 116); break;
                    case TokenType::LESSEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 118); break;
                }
                break;
            case 154:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::CompLGTExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::CompEQExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CompEQExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::CompEQExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::GREATER:
                        shift(p, lasttok, lookahead, stack, steps, 117); break;
                    case TokenType::GREATEREQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 119); break;
                    case TokenType::LESS:
                        shift(p, lasttok, lookahead, stack, steps, 116); break;
                    case TokenType::LESSEQUAL:
                        shift(p, lasttok, lookahead, stack, steps, 118); break;
                }
                break;
            case 155:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::BitXorExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::CompLGTExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CompLGTExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::CompLGTExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 120); break;
                }
                break;
            case 156:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::BitXorExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::CompLGTExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CompLGTExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::CompLGTExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 120); break;
                }
                break;
            case 157:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::BitXorExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::CompLGTExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CompLGTExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::CompLGTExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 120); break;
                }
                break;
            case 158:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::BitXorExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::CompLGTExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CompLGTExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::CompLGTExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::CARET:
                        shift(p, lasttok, lookahead, stack, steps, 120); break;
                }
                break;
            case 159:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::BitOrExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BitXorExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BitXorExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::BitXorExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::PIPE:
                        shift(p, lasttok, lookahead, stack, steps, 121); break;
                }
                break;
            case 160:
               switch (lookahead.type)
               {
                    case TokenType::AMPER:
                        shift(p, lasttok, lookahead, stack, steps, 122); break;
                    default:
                        {
                            auto a2 (popA<ASTNS::BitAndExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BitOrExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BitOrExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::BitOrExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 161:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::BitShiftExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BitAndExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BitAndExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::BitAndExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DOUBLEGREATER:
                        shift(p, lasttok, lookahead, stack, steps, 123); break;
                    case TokenType::DOUBLELESS:
                        shift(p, lasttok, lookahead, stack, steps, 124); break;
                }
                break;
            case 162:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::AdditionExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BitShiftExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BitShiftExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::BitShiftExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 126); break;
                    case TokenType::PLUS:
                        shift(p, lasttok, lookahead, stack, steps, 125); break;
                }
                break;
            case 163:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::AdditionExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::BitShiftExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BitShiftExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::BitShiftExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 126); break;
                    case TokenType::PLUS:
                        shift(p, lasttok, lookahead, stack, steps, 125); break;
                }
                break;
            case 164:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::MultExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::AdditionExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::AdditionExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::AdditionExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::PERCENT:
                        shift(p, lasttok, lookahead, stack, steps, 129); break;
                    case TokenType::SLASH:
                        shift(p, lasttok, lookahead, stack, steps, 128); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 127); break;
                }
                break;
            case 165:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::MultExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::AdditionExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::AdditionExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::AdditionExpr>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::PERCENT:
                        shift(p, lasttok, lookahead, stack, steps, 129); break;
                    case TokenType::SLASH:
                        shift(p, lasttok, lookahead, stack, steps, 128); break;
                    case TokenType::STAR:
                        shift(p, lasttok, lookahead, stack, steps, 127); break;
                }
                break;
            case 166:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::UnaryExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::MultExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::MultExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::MultExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 167:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::UnaryExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::MultExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::MultExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::MultExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 168:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::UnaryExpr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::MultExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::MultExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::MultExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 169:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "type cast expression", "type cast expression")  });
                }
                break;
            case 170:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::PrimaryExpr>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::PrimaryExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 171:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 187); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "function call expression")  });
                }
                break;
            case 172:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::ArgList_OPT>(stack);
                        break;
                }
                break;
            case 173:
               switch (lookahead.type)
               {
                    case TokenType::COMMA:
                        shift(p, lasttok, lookahead, stack, steps, 188); break;
                    case TokenType::CPARN:
                        reduceSkip<ASTNS::ArgList>(stack);
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::COMMA), "argument list"), format("expected % for %", stringifyTokenType(TokenType::COMMA), "argument list"), format("expected % to terminate %", stringifyTokenType(TokenType::CPARN), "argument list")  });
                }
                break;
            case 174:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::ArgSegment>(stack);
                        break;
                }
                break;
            case 175:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a0 (popA<ASTNS::Expr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::Arg>(std::move(a0)));
                            stack.emplace_back(getGoto<ASTNS::Arg>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 176:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::ImplRet_OPT>(stack));
                            auto a2 (popA<ASTNS::StmtList_OPT>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::IndentedBlock>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4)));
                            stack.emplace_back(getGoto<ASTNS::IndentedBlock>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 177:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::LineEnding_OPT>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ImplRet>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::ImplRet>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 178:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::ImplRet_OPT>(stack));
                            auto a2 (popA<ASTNS::StmtList_OPT>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BracedBlock>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4)));
                            stack.emplace_back(getGoto<ASTNS::BracedBlock>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 179:
               switch (lookahead.type)
               {
                    case TokenType::DEDENT:
                        shift(p, lasttok, lookahead, stack, steps, 189); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::DEDENT), "braced code block")  });
                }
                break;
            case 180:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a3 (popA<ASTNS::LineEnding>(stack));
                            auto a2 (popA<ASTNS::VarStmtItemList>(stack));
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::VarStmt>(std::move(a0), std::move(a1), std::move(a2), std::move(a3)));
                            stack.emplace_back(getGoto<ASTNS::VarStmt>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 181:
               switch (lookahead.type)
               {
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 145); break;
                    case TokenType::NEWLINE:
                    case TokenType::SEMICOLON:
                        {
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::VarStmtItemSegment>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::VarStmtItemList>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::VarStmtItemList>(stack.back().state), std::move(push));
                        }
                        break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "another variable statement initialization", "variable statement initialization list"), format("expected % to terminate %", format("either % or %", stringifyTokenType(TokenType::NEWLINE), stringifyTokenType(TokenType::SEMICOLON)), "variable statement initialization list")  });
                }
                break;
            case 182:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "expression", "variable statement initialization")  });
                }
                break;
            case 183:
               switch (lookahead.type)
               {
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 150); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", format("either % or %", "code block", "if expression"), "if expression")  });
                }
                break;
            case 184:
               switch (lookahead.type)
               {
                    case TokenType::SEMICOLON:
                        shift(p, lasttok, lookahead, stack, steps, 195); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::SEMICOLON), "for expression")  });
                }
                break;
            case 185:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::Expr_OPT>(stack);
                        break;
                }
                break;
            case 186:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a3 (popA<ASTNS::CastExpr>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::Type>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CastExpr>(std::move(a0), std::move(a1), std::move(a2), std::move(a3)));
                            stack.emplace_back(getGoto<ASTNS::CastExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 187:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::ArgList_OPT>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::CallExpr>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::CallExpr>(std::move(a0), std::move(a1), std::move(a2), std::move(a3)));
                            stack.emplace_back(getGoto<ASTNS::CallExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 188:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    case TokenType::CPARN:
                        {
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ArgSegment>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ArgList>(std::move(a0), std::move(a1)));
                            stack.emplace_back(getGoto<ASTNS::ArgList>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "another argument", "argument list"), format("expected % to terminate %", stringifyTokenType(TokenType::CPARN), "argument list")  });
                }
                break;
            case 189:
               switch (lookahead.type)
               {
                    case TokenType::CCURB:
                        shift(p, lasttok, lookahead, stack, steps, 198); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CCURB), "braced code block")  });
                }
                break;
            case 190:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::AnotherVarStmtItem>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::VarStmtItemSegment>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::VarStmtItemSegment>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::VarStmtItemSegment>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 191:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::AnotherVarStmtItem>(stack);
                        break;
                }
                break;
            case 192:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::Expr>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::VarStmtItem>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::VarStmtItem>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 193:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a4 (popA<ASTNS::Block>(stack));
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::Block>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::IfExpr>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4)));
                            stack.emplace_back(getGoto<ASTNS::IfExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 194:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a4 (popA<ASTNS::IfExpr>(stack));
                            auto a3 (popT(stack));
                            auto a2 (popA<ASTNS::Block>(stack));
                            auto a1 (popA<ASTNS::Expr>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::IfExpr>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4)));
                            stack.emplace_back(getGoto<ASTNS::IfExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 195:
               switch (lookahead.type)
               {
                    case TokenType::BANG:
                        shift(p, lasttok, lookahead, stack, steps, 79); break;
                    case TokenType::BININTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 88); break;
                    case TokenType::CHARLIT:
                        shift(p, lasttok, lookahead, stack, steps, 90); break;
                    default:
                        {
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::Expr_OPT>());
                            stack.emplace_back(getGoto<ASTNS::Expr_OPT>(stack.back().state), std::move(push));
                        }
                        break;
                    case TokenType::DECINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 86); break;
                    case TokenType::FALSELIT:
                        shift(p, lasttok, lookahead, stack, steps, 83); break;
                    case TokenType::FLOATLIT:
                        shift(p, lasttok, lookahead, stack, steps, 84); break;
                    case TokenType::FOR:
                        shift(p, lasttok, lookahead, stack, steps, 64); break;
                    case TokenType::HEXINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 89); break;
                    case TokenType::IDENTIFIER:
                        shift(p, lasttok, lookahead, stack, steps, 92); break;
                    case TokenType::IF:
                        shift(p, lasttok, lookahead, stack, steps, 63); break;
                    case TokenType::MINUS:
                        shift(p, lasttok, lookahead, stack, steps, 78); break;
                    case TokenType::NULLPTRLIT:
                        shift(p, lasttok, lookahead, stack, steps, 85); break;
                    case TokenType::OCTINTLIT:
                        shift(p, lasttok, lookahead, stack, steps, 87); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    case TokenType::OPARN:
                        shift(p, lasttok, lookahead, stack, steps, 75); break;
                    case TokenType::STRINGLIT:
                        shift(p, lasttok, lookahead, stack, steps, 91); break;
                    case TokenType::TILDE:
                        shift(p, lasttok, lookahead, stack, steps, 77); break;
                    case TokenType::TRUELIT:
                        shift(p, lasttok, lookahead, stack, steps, 82); break;
                }
                break;
            case 196:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a2 (popA<ASTNS::AnotherArg>(stack));
                            auto a1 (popT(stack));
                            auto a0 (popA<ASTNS::ArgSegment>(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ArgSegment>(std::move(a0), std::move(a1), std::move(a2)));
                            stack.emplace_back(getGoto<ASTNS::ArgSegment>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 197:
               switch (lookahead.type)
               {
                    default:
                        reduceSkip<ASTNS::AnotherArg>(stack);
                        break;
                }
                break;
            case 198:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a6 (popT(stack));
                            auto a5 (popT(stack));
                            auto a4 (popA<ASTNS::ImplRet_OPT>(stack));
                            auto a3 (popA<ASTNS::StmtList_OPT>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popT(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::BracedBlock>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4), std::move(a5), std::move(a6)));
                            stack.emplace_back(getGoto<ASTNS::BracedBlock>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            case 199:
               switch (lookahead.type)
               {
                    case TokenType::CPARN:
                        shift(p, lasttok, lookahead, stack, steps, 200); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", stringifyTokenType(TokenType::CPARN), "for expression")  });
                }
                break;
            case 200:
               switch (lookahead.type)
               {
                    case TokenType::NEWLINE:
                        shift(p, lasttok, lookahead, stack, steps, 150); break;
                    case TokenType::OCURB:
                        shift(p, lasttok, lookahead, stack, steps, 39); break;
                    default:
                        if (istrial) return false;
                        error(done, errored, errorstate(p, stack, lasttok, lookahead), std::vector<std::string> {  format("expected % for %", "code block", "for expression")  });
                }
                break;
            case 201:
               switch (lookahead.type)
               {
                    default:
                        {
                            auto a7 (popA<ASTNS::Block>(stack));
                            auto a6 (popT(stack));
                            auto a5 (popA<ASTNS::Expr_OPT>(stack));
                            auto a4 (popT(stack));
                            auto a3 (popA<ASTNS::Expr_OPT>(stack));
                            auto a2 (popT(stack));
                            auto a1 (popA<ASTNS::VarStmt_OPT>(stack));
                            auto a0 (popT(stack));
                            std::unique_ptr<ASTNS::AST> push (std::make_unique<ASTNS::ForExpr>(std::move(a0), std::move(a1), std::move(a2), std::move(a3), std::move(a4), std::move(a5), std::move(a6), std::move(a7)));
                            stack.emplace_back(getGoto<ASTNS::ForExpr>(stack.back().state), std::move(push));
                        }
                        break;
                }
                break;
            default:
                reportAbortNoh(format("Parser reached invalid state: %", stack.back().state));
        }
    }
// This code was autogenerated - see the utils/ directory

    // PARSERLOOP END
    // }}}

    if (istrial)
        return true;

    if (errored)
    {
        p.errored = true;
        out = nullptr;
        return false;
    }

    stackitem topsi (std::move(stack.back()));
    ASSERT(!topsi.istok)

    std::unique_ptr<ASTNS::AST> astu (std::move(topsi.ast));
    ASTNS::CUB *cub = dynamic_cast<ASTNS::CUB*>(astu.get());

    ASSERT(cub)

    astu.release();
    out = std::unique_ptr<ASTNS::CUB>(cub);
    return true;
}
