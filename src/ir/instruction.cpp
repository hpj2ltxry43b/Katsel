#include "ir/instruction.h"
#include "ir/value.h"
#include "ir/type.h"
#include "ir/visitor.h"
#include "llvm/Support/raw_ostream.h"
#include "utils/assert.h"

// INSTR CPP START

// The following code was autogenerated - see the utils/ directory
IR::Instrs::Store::Store(Register *target, ASTValue value): target(target), value(value)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(target->type() == value.type())
}
void IR::Instrs::Store::accept(InstructionVisitor *v) { v->visitStore(this); }
IR::Instrs::Phi::Phi(TempRegister *target, std::vector<std::pair<Block*,ASTValue>> prevs): target(target), prevs(prevs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
}
void IR::Instrs::Phi::accept(InstructionVisitor *v) { v->visitPhi(this); }
IR::Instrs::Or::Or(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
}
void IR::Instrs::Or::accept(InstructionVisitor *v) { v->visitOr(this); }
IR::Instrs::And::And(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
}
void IR::Instrs::And::accept(InstructionVisitor *v) { v->visitAnd(this); }
IR::Instrs::CmpNE::CmpNE(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::CmpNE::accept(InstructionVisitor *v) { v->visitCmpNE(this); }
IR::Instrs::CmpEQ::CmpEQ(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::CmpEQ::accept(InstructionVisitor *v) { v->visitCmpEQ(this); }
IR::Instrs::CmpLT::CmpLT(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::CmpLT::accept(InstructionVisitor *v) { v->visitCmpLT(this); }
IR::Instrs::CmpGT::CmpGT(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::CmpGT::accept(InstructionVisitor *v) { v->visitCmpGT(this); }
IR::Instrs::CmpLE::CmpLE(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::CmpLE::accept(InstructionVisitor *v) { v->visitCmpLE(this); }
IR::Instrs::CmpGE::CmpGE(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::CmpGE::accept(InstructionVisitor *v) { v->visitCmpGE(this); }
IR::Instrs::BitXor::BitXor(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::BitXor::accept(InstructionVisitor *v) { v->visitBitXor(this); }
IR::Instrs::BitOr::BitOr(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::BitOr::accept(InstructionVisitor *v) { v->visitBitOr(this); }
IR::Instrs::BitAnd::BitAnd(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::BitAnd::accept(InstructionVisitor *v) { v->visitBitAnd(this); }
IR::Instrs::BitNot::BitNot(TempRegister *target, ASTValue op): target(target), op(op)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(op.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(op.type()))
}
void IR::Instrs::BitNot::accept(InstructionVisitor *v) { v->visitBitNot(this); }
IR::Instrs::ShiftR::ShiftR(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::ShiftR::accept(InstructionVisitor *v) { v->visitShiftR(this); }
IR::Instrs::ShiftL::ShiftL(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::ShiftL::accept(InstructionVisitor *v) { v->visitShiftL(this); }
IR::Instrs::Add::Add(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::Add::accept(InstructionVisitor *v) { v->visitAdd(this); }
IR::Instrs::Sub::Sub(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::Sub::accept(InstructionVisitor *v) { v->visitSub(this); }
IR::Instrs::Mult::Mult(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::Mult::accept(InstructionVisitor *v) { v->visitMult(this); }
IR::Instrs::Div::Div(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::Div::accept(InstructionVisitor *v) { v->visitDiv(this); }
IR::Instrs::Mod::Mod(TempRegister *target, ASTValue lhs, ASTValue rhs): target(target), lhs(lhs), rhs(rhs)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(lhs.type() == rhs.type())
    ASSERT(lhs.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(lhs.type()))
}
void IR::Instrs::Mod::accept(InstructionVisitor *v) { v->visitMod(this); }
IR::Instrs::Neg::Neg(TempRegister *target, ASTValue op): target(target), op(op)
{
    ASSERT(!dynamic_cast<IR::VoidType*>(target->type()))
    ASSERT(op.type() == target->type())
    ASSERT(dynamic_cast<BuiltinType*>(op.type()))
}
void IR::Instrs::Neg::accept(InstructionVisitor *v) { v->visitNeg(this); }
IR::Instrs::Trunc::Trunc(TempRegister *target, ASTValue op, BuiltinType *newt): target(target), op(op), newt(newt)
{
    ASSERT(target->type() == newt)
    ASSERT(dynamic_cast<BuiltinType*>(op.type()))
    ASSERT(static_cast<BuiltinType*>(op.type())->isFloating() == newt->isFloating())
}
void IR::Instrs::Trunc::accept(InstructionVisitor *v) { v->visitTrunc(this); }
IR::Instrs::Ext::Ext(TempRegister *target, ASTValue op, BuiltinType *newt): target(target), op(op), newt(newt)
{
    ASSERT(target->type() == newt)
    ASSERT(dynamic_cast<BuiltinType*>(op.type()))
    ASSERT(static_cast<BuiltinType*>(op.type())->isFloating() == newt->isFloating())
}
void IR::Instrs::Ext::accept(InstructionVisitor *v) { v->visitExt(this); }
IR::Instrs::IntToFloat::IntToFloat(TempRegister *target, ASTValue op, BuiltinType *newt): target(target), op(op), newt(newt)
{
    ASSERT(target->type() == newt)
    ASSERT(dynamic_cast<BuiltinType*>(op.type()))
    ASSERT(!static_cast<BuiltinType*>(op.type())->isFloating())
    ASSERT(newt->isFloating())
}
void IR::Instrs::IntToFloat::accept(InstructionVisitor *v) { v->visitIntToFloat(this); }
IR::Instrs::FloatToInt::FloatToInt(TempRegister *target, ASTValue op, BuiltinType *newt): target(target), op(op), newt(newt)
{
    ASSERT(target->type() == newt)
    ASSERT(dynamic_cast<BuiltinType*>(op.type()))
    ASSERT(static_cast<BuiltinType*>(op.type())->isFloating())
    ASSERT(!newt->isFloating())
}
void IR::Instrs::FloatToInt::accept(InstructionVisitor *v) { v->visitFloatToInt(this); }
IR::Instrs::Return::Return(Register *value): value(value)
{
}
void IR::Instrs::Return::accept(InstructionVisitor *v) { v->visitReturn(this); }
IR::Instrs::Call::Call(TempRegister *reg, Function *f, std::vector<ASTValue> args): reg(reg), f(f), args(args)
{
    ASSERT(reg->type() == f->ty->ret)
}
void IR::Instrs::Call::accept(InstructionVisitor *v) { v->visitCall(this); }
IR::Instrs::GotoBr::GotoBr(Block *to): to(to)
{
}
void IR::Instrs::GotoBr::accept(BrVisitor *v) { v->visitGotoBr(this); }
IR::Instrs::CondBr::CondBr(ASTValue v, Block *trueB, Block *falseB): v(v), trueB(trueB), falseB(falseB)
{
}
void IR::Instrs::CondBr::accept(BrVisitor *v) { v->visitCondBr(this); }
// This code was autogenerated - see the utils/ directory

// INSTR CPP END
