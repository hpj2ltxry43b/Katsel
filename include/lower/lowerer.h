#pragma once

#include "ir/instructionfwd.h"
#include "ir/value.h"
#include "ir/unit.h"
#include "ir/visitor.h"
#include "mangle/mangler.h"

#include <unordered_map>

#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/LegacyPassManager.h"

namespace Lower {
    class Lowerer : public IR::InstructionVisitor, public IR::BrVisitor, public IR::ValueVisitor {
    public:
        Lowerer(IR::Unit const &unit);

        // LOWER VISIT INSTR START
// The following code was autogenerated - see the utils/ directory
void visit_store(IR::Instrs::Store &i) override;
void visit_phi(IR::Instrs::Phi &i) override;
void visit_register(IR::Instrs::Register &i) override;
void visit_or(IR::Instrs::Or &i) override;
void visit_and(IR::Instrs::And &i) override;
void visit_not(IR::Instrs::Not &i) override;
void visit_icmp_ne(IR::Instrs::ICmpNE &i) override;
void visit_icmp_eq(IR::Instrs::ICmpEQ &i) override;
void visit_icmp_lt(IR::Instrs::ICmpLT &i) override;
void visit_icmp_gt(IR::Instrs::ICmpGT &i) override;
void visit_icmp_le(IR::Instrs::ICmpLE &i) override;
void visit_icmp_ge(IR::Instrs::ICmpGE &i) override;
void visit_iadd(IR::Instrs::IAdd &i) override;
void visit_isub(IR::Instrs::ISub &i) override;
void visit_imult(IR::Instrs::IMult &i) override;
void visit_idiv(IR::Instrs::IDiv &i) override;
void visit_imod(IR::Instrs::IMod &i) override;
void visit_ineg(IR::Instrs::INeg &i) override;
void visit_fcmp_ne(IR::Instrs::FCmpNE &i) override;
void visit_fcmp_eq(IR::Instrs::FCmpEQ &i) override;
void visit_fcmp_lt(IR::Instrs::FCmpLT &i) override;
void visit_fcmp_gt(IR::Instrs::FCmpGT &i) override;
void visit_fcmp_le(IR::Instrs::FCmpLE &i) override;
void visit_fcmp_ge(IR::Instrs::FCmpGE &i) override;
void visit_fadd(IR::Instrs::FAdd &i) override;
void visit_fsub(IR::Instrs::FSub &i) override;
void visit_fmult(IR::Instrs::FMult &i) override;
void visit_fdiv(IR::Instrs::FDiv &i) override;
void visit_fmod(IR::Instrs::FMod &i) override;
void visit_fneg(IR::Instrs::FNeg &i) override;
void visit_bit_xor(IR::Instrs::BitXor &i) override;
void visit_bit_or(IR::Instrs::BitOr &i) override;
void visit_bit_and(IR::Instrs::BitAnd &i) override;
void visit_bit_not(IR::Instrs::BitNot &i) override;
void visit_shift_r(IR::Instrs::ShiftR &i) override;
void visit_shift_l(IR::Instrs::ShiftL &i) override;
void visit_no_op_cast(IR::Instrs::NoOpCast &i) override;
void visit_int_to_int(IR::Instrs::IntToInt &i) override;
void visit_int_to_float(IR::Instrs::IntToFloat &i) override;
void visit_float_to_float(IR::Instrs::FloatToFloat &i) override;
void visit_float_to_int(IR::Instrs::FloatToInt &i) override;
void visit_call(IR::Instrs::Call &i) override;
void visit_addrof(IR::Instrs::Addrof &i) override;
void visit_deref_ptr(IR::Instrs::DerefPtr &i) override;
void visit_ptr_arith(IR::Instrs::PtrArith &i) override;
// This code was autogenerated - see the utils/ directory
        // LOWER VISIT INSTR END
        // LOWER VISIT BRANCH START
// The following code was autogenerated - see the utils/ directory
void visit_return(IR::Instrs::Return &i) override;
void visit_goto_br(IR::Instrs::GotoBr &i) override;
void visit_cond_br(IR::Instrs::CondBr &i) override;
// This code was autogenerated - see the utils/ directory
        // LOWER VISIT BRANCH END

#define METHOD(cl, n) \
        void value_visit##n(IR::cl &v) override;
        IR_VALUE_LIST(METHOD)
#undef METHOD

        void lower();
        bool objectify(llvm::raw_fd_ostream &ostream);

        void print_mod(llvm::raw_ostream &ostream);

        bool errored;

    private:
        void lower(IR::Function const &f);
        void lower(IR::Block const &b);
        NNPtr<llvm::Value> lower(NNPtr<IR::Value> v);
        NNPtr<llvm::Value> lower(IR::ASTValue &v);

        IR::Unit const &unit;

        llvm::LLVMContext context;
        llvm::IRBuilder<> builder;
        llvm::Module mod;
        llvm::legacy::FunctionPassManager fpm;

        std::unordered_map<NNPtr<IR::Instrs::Instruction const> , llvm::Value*> values;
        std::unordered_map<NNPtr<IR::Block const> , llvm::BasicBlock*> blocks;
        std::unordered_map<NNPtr<IR::Function const> , llvm::Function*> functions;

        Mangle::NameMangler mangler;

        int alloca_index;
        llvm::Function *cur_function;

        llvm::Value *lvret;
    };
}
