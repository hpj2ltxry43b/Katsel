#pragma once

#include "llvm/Support/raw_ostream.h"
#include <vector>

#include "ir/value.h"

namespace IR
{
    class Register;
    class Function;
    class Value;
    class Type;

    class Block;

    class InstructionVisitor;
    class BrVisitor;

    namespace Instrs
    {
        class Instruction
        {
        public:
            virtual ~Instruction() {};
            virtual void accept(InstructionVisitor *v) = 0;
        };

        class Br
        {
        public:
            virtual ~Br() {};
            virtual void accept(BrVisitor *v) = 0;
        };

        // INSTR CLASSES START

// The following code was autogenerated - see the utils/ directory
    class Store : public Instruction
    {
    public:
        Store(Register *target, ASTValue value);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue value;
    };
    class Phi : public Instruction
    {
    public:
        Phi(TempRegister *target, std::vector<std::pair<Block*,ASTValue>> prevs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        std::vector<std::pair<Block*,ASTValue>> prevs;
    };
    class Or : public Instruction
    {
    public:
        Or(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class And : public Instruction
    {
    public:
        And(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpNE : public Instruction
    {
    public:
        CmpNE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpEQ : public Instruction
    {
    public:
        CmpEQ(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpLT : public Instruction
    {
    public:
        CmpLT(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpGT : public Instruction
    {
    public:
        CmpGT(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpLE : public Instruction
    {
    public:
        CmpLE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpGE : public Instruction
    {
    public:
        CmpGE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitXor : public Instruction
    {
    public:
        BitXor(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitOr : public Instruction
    {
    public:
        BitOr(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitAnd : public Instruction
    {
    public:
        BitAnd(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitNot : public Instruction
    {
    public:
        BitNot(TempRegister *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
    };
    class ShiftR : public Instruction
    {
    public:
        ShiftR(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ShiftL : public Instruction
    {
    public:
        ShiftL(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Add : public Instruction
    {
    public:
        Add(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Sub : public Instruction
    {
    public:
        Sub(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Mult : public Instruction
    {
    public:
        Mult(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Div : public Instruction
    {
    public:
        Div(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Mod : public Instruction
    {
    public:
        Mod(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Neg : public Instruction
    {
    public:
        Neg(TempRegister *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
    };
    class Trunc : public Instruction
    {
    public:
        Trunc(TempRegister *target, ASTValue op, BuiltinType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        BuiltinType *newt;
    };
    class Ext : public Instruction
    {
    public:
        Ext(TempRegister *target, ASTValue op, BuiltinType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        BuiltinType *newt;
    };
    class IntToFloat : public Instruction
    {
    public:
        IntToFloat(TempRegister *target, ASTValue op, BuiltinType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        BuiltinType *newt;
    };
    class FloatToInt : public Instruction
    {
    public:
        FloatToInt(TempRegister *target, ASTValue op, BuiltinType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        BuiltinType *newt;
    };
    class Return : public Instruction
    {
    public:
        Return(Register *value);
        void accept(InstructionVisitor *v) override;
        Register *value;
    };
    class Call : public Instruction
    {
    public:
        Call(TempRegister *reg, Function *f, std::vector<ASTValue> args);
        void accept(InstructionVisitor *v) override;
        TempRegister *reg;
        Function *f;
        std::vector<ASTValue> args;
    };
    class GotoBr : public Br
    {
    public:
        GotoBr(Block *to);
        void accept(BrVisitor *v) override;
        Block *to;
    };
    class CondBr : public Br
    {
    public:
        CondBr(ASTValue v, Block *trueB, Block *falseB);
        void accept(BrVisitor *v) override;
        ASTValue v;
        Block *trueB;
        Block *falseB;
    };
// This code was autogenerated - see the utils/ directory

        // INSTR CLASSES END
    }
}
