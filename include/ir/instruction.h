#pragma once

#include "llvm/Support/raw_ostream.h"
#include <vector>

#include "ir/value.h"

namespace IR
{
    class Register;
    class Function;
    class Value;
    class Type;

    class Block;

    class InstructionVisitor;
    class BrVisitor;

    namespace Instrs
    {
        class Instruction
        {
        public:
            virtual ~Instruction() {};
            virtual void accept(InstructionVisitor *v) = 0;
        };

        class Br
        {
        public:
            virtual ~Br() {};
            virtual void accept(BrVisitor *v) = 0;
        };

        // INSTR CLASSES START

// The following code was autogenerated - see the utils/ directory
    class Store : public Instruction
    {
    public:
        Store(Register *target, ASTValue value);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue value;
    };
    class Phi : public Instruction
    {
    public:
        Phi(TempRegister *target, std::vector<std::pair<Block*,ASTValue>> prevs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        std::vector<std::pair<Block*,ASTValue>> prevs;
    };
    class Or : public Instruction
    {
    public:
        Or(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class And : public Instruction
    {
    public:
        And(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ShortOr : public Instruction
    {
    public:
        ShortOr(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ShortAnd : public Instruction
    {
    public:
        ShortAnd(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Not : public Instruction
    {
    public:
        Not(TempRegister *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
    };
    class ICmpNE : public Instruction
    {
    public:
        ICmpNE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ICmpEQ : public Instruction
    {
    public:
        ICmpEQ(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ICmpLT : public Instruction
    {
    public:
        ICmpLT(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ICmpGT : public Instruction
    {
    public:
        ICmpGT(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ICmpLE : public Instruction
    {
    public:
        ICmpLE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ICmpGE : public Instruction
    {
    public:
        ICmpGE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class IAdd : public Instruction
    {
    public:
        IAdd(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ISub : public Instruction
    {
    public:
        ISub(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class IMult : public Instruction
    {
    public:
        IMult(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class IDiv : public Instruction
    {
    public:
        IDiv(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class IMod : public Instruction
    {
    public:
        IMod(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class INeg : public Instruction
    {
    public:
        INeg(TempRegister *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
    };
    class FCmpNE : public Instruction
    {
    public:
        FCmpNE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FCmpEQ : public Instruction
    {
    public:
        FCmpEQ(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FCmpLT : public Instruction
    {
    public:
        FCmpLT(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FCmpGT : public Instruction
    {
    public:
        FCmpGT(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FCmpLE : public Instruction
    {
    public:
        FCmpLE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FCmpGE : public Instruction
    {
    public:
        FCmpGE(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FAdd : public Instruction
    {
    public:
        FAdd(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FSub : public Instruction
    {
    public:
        FSub(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FMult : public Instruction
    {
    public:
        FMult(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FDiv : public Instruction
    {
    public:
        FDiv(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FMod : public Instruction
    {
    public:
        FMod(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class FNeg : public Instruction
    {
    public:
        FNeg(TempRegister *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
    };
    class BitXor : public Instruction
    {
    public:
        BitXor(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitOr : public Instruction
    {
    public:
        BitOr(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitAnd : public Instruction
    {
    public:
        BitAnd(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitNot : public Instruction
    {
    public:
        BitNot(TempRegister *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
    };
    class ShiftR : public Instruction
    {
    public:
        ShiftR(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ShiftL : public Instruction
    {
    public:
        ShiftL(TempRegister *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class NoOpCast : public Instruction
    {
    public:
        NoOpCast(TempRegister *target, ASTValue op, Type *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        Type *newt;
    };
    class IntToInt : public Instruction
    {
    public:
        IntToInt(TempRegister *target, ASTValue op, IntType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        IntType *newt;
    };
    class IntToFloat : public Instruction
    {
    public:
        IntToFloat(TempRegister *target, ASTValue op, FloatType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        FloatType *newt;
    };
    class FloatToFloat : public Instruction
    {
    public:
        FloatToFloat(TempRegister *target, ASTValue op, FloatType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        FloatType *newt;
    };
    class FloatToInt : public Instruction
    {
    public:
        FloatToInt(TempRegister *target, ASTValue op, IntType *newt);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        ASTValue op;
        IntType *newt;
    };
    class Call : public Instruction
    {
    public:
        Call(TempRegister *target, Function *f, std::vector<ASTValue> args);
        void accept(InstructionVisitor *v) override;
        TempRegister *target;
        Function *f;
        std::vector<ASTValue> args;
    };
    class Return : public Br
    {
    public:
        Return(Register *value);
        void accept(BrVisitor *v) override;
        Register *value;
    };
    class GotoBr : public Br
    {
    public:
        GotoBr(Block *to);
        void accept(BrVisitor *v) override;
        Block *to;
    };
    class CondBr : public Br
    {
    public:
        CondBr(ASTValue v, Block *trueB, Block *falseB);
        void accept(BrVisitor *v) override;
        ASTValue v;
        Block *trueB;
        Block *falseB;
    };
// This code was autogenerated - see the utils/ directory

        // INSTR CLASSES END
    }
}
