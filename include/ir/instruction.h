#pragma once

#include <ostream>
#include <vector>

namespace IR
{
    class Register;
    class Function;
    class Value;

    class Block;
    class Type;

    class InstructionVisitor;
    class BrVisitor;

    namespace Instrs
    {
        class Instruction
        {
        public:
            virtual ~Instruction() {};
            virtual void accept(InstructionVisitor *v) = 0;
        };

        class Br
        {
        public:
            virtual ~Br() {};
            virtual void accept(BrVisitor *v) = 0;
        };

        // INSTR CLASSES START

// The following code was autogenerated - see the utils/ directory
    class Store : public Instruction
    {
    public:
        Store(Register *target, Value *value);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *value;
    };
    class Or : public Instruction
    {
    public:
        Or(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class And : public Instruction
    {
    public:
        And(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class IntCmpNE : public Instruction
    {
    public:
        IntCmpNE(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class IntCmpEQ : public Instruction
    {
    public:
        IntCmpEQ(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class IntCmpULT : public Instruction
    {
    public:
        IntCmpULT(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class IntCmpUGT : public Instruction
    {
    public:
        IntCmpUGT(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class IntCmpULE : public Instruction
    {
    public:
        IntCmpULE(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class IntCmpUGE : public Instruction
    {
    public:
        IntCmpUGE(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class FloatCmpNE : public Instruction
    {
    public:
        FloatCmpNE(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class FloatCmpEQ : public Instruction
    {
    public:
        FloatCmpEQ(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class FloatCmpULT : public Instruction
    {
    public:
        FloatCmpULT(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class FloatCmpUGT : public Instruction
    {
    public:
        FloatCmpUGT(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class FloatCmpULE : public Instruction
    {
    public:
        FloatCmpULE(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class FloatCmpUGE : public Instruction
    {
    public:
        FloatCmpUGE(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class BitXor : public Instruction
    {
    public:
        BitXor(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class BitOr : public Instruction
    {
    public:
        BitOr(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class BitAnd : public Instruction
    {
    public:
        BitAnd(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class BitNot : public Instruction
    {
    public:
        BitNot(Register *target, Value *op);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
    };
    class ShiftR : public Instruction
    {
    public:
        ShiftR(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class ShiftL : public Instruction
    {
    public:
        ShiftL(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class Add : public Instruction
    {
    public:
        Add(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class Sub : public Instruction
    {
    public:
        Sub(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class Mult : public Instruction
    {
    public:
        Mult(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class Div : public Instruction
    {
    public:
        Div(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class Mod : public Instruction
    {
    public:
        Mod(Register *target, Value *lhs, Value *rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *lhs;
        Value *rhs;
    };
    class Neg : public Instruction
    {
    public:
        Neg(Register *target, Value *op);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
    };
    class Trunc : public Instruction
    {
    public:
        Trunc(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class ZeroExt : public Instruction
    {
    public:
        ZeroExt(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class SignExt : public Instruction
    {
    public:
        SignExt(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class FloatTrunc : public Instruction
    {
    public:
        FloatTrunc(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class FloatExt : public Instruction
    {
    public:
        FloatExt(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class SIntToFloat : public Instruction
    {
    public:
        SIntToFloat(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class UIntToFloat : public Instruction
    {
    public:
        UIntToFloat(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class FloatToSInt : public Instruction
    {
    public:
        FloatToSInt(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class FloatToUInt : public Instruction
    {
    public:
        FloatToUInt(Register *target, Value *op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        Value *op;
        Type *newt;
    };
    class Return : public Instruction
    {
    public:
        Return(Value *value);
        void accept(InstructionVisitor *v) override;
        Value *value;
    };
    class Call : public Instruction
    {
    public:
        Call(Register *reg, Function *f, std::vector<Value*> args);
        void accept(InstructionVisitor *v) override;
        Register *reg;
        Function *f;
        std::vector<Value*> args;
    };
    class GotoBr : public Br
    {
    public:
        GotoBr(Block *b);
        void accept(BrVisitor *v) override;
        Block *b;
    };
    class CondBr : public Br
    {
    public:
        CondBr(Value *v, Block *trueb, Block *falseb);
        void accept(BrVisitor *v) override;
        Value *v;
        Block *trueb;
        Block *falseb;
    };
// This code was autogenerated - see the utils/ directory

        // INSTR CLASSES END
    }
}
