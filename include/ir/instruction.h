#pragma once

#include <ostream>
#include <vector>

#include "ir/value.h"

namespace IR
{
    class Register;
    class Function;
    class Value;
    class Type;

    class Block;

    class InstructionVisitor;
    class BrVisitor;

    namespace Instrs
    {
        class Instruction
        {
        public:
            virtual ~Instruction() {};
            virtual void accept(InstructionVisitor *v) = 0;
        };

        class Br
        {
        public:
            virtual ~Br() {};
            virtual void accept(BrVisitor *v) = 0;
        };

        // INSTR CLASSES START

// The following code was autogenerated - see the utils/ directory
    class Store : public Instruction
    {
    public:
        Store(Register *target, ASTValue value);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue value;
    };
    class Or : public Instruction
    {
    public:
        Or(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class And : public Instruction
    {
    public:
        And(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpNE : public Instruction
    {
    public:
        CmpNE(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpEQ : public Instruction
    {
    public:
        CmpEQ(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpLT : public Instruction
    {
    public:
        CmpLT(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpGT : public Instruction
    {
    public:
        CmpGT(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpLE : public Instruction
    {
    public:
        CmpLE(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class CmpGE : public Instruction
    {
    public:
        CmpGE(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitXor : public Instruction
    {
    public:
        BitXor(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitOr : public Instruction
    {
    public:
        BitOr(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitAnd : public Instruction
    {
    public:
        BitAnd(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class BitNot : public Instruction
    {
    public:
        BitNot(Register *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue op;
    };
    class ShiftR : public Instruction
    {
    public:
        ShiftR(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class ShiftL : public Instruction
    {
    public:
        ShiftL(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Add : public Instruction
    {
    public:
        Add(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Sub : public Instruction
    {
    public:
        Sub(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Mult : public Instruction
    {
    public:
        Mult(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Div : public Instruction
    {
    public:
        Div(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Mod : public Instruction
    {
    public:
        Mod(Register *target, ASTValue lhs, ASTValue rhs);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue lhs;
        ASTValue rhs;
    };
    class Neg : public Instruction
    {
    public:
        Neg(Register *target, ASTValue op);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue op;
    };
    class Trunc : public Instruction
    {
    public:
        Trunc(Register *target, ASTValue op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue op;
        Type *newt;
    };
    class Ext : public Instruction
    {
    public:
        Ext(Register *target, ASTValue op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue op;
        Type *newt;
    };
    class IntToFloat : public Instruction
    {
    public:
        IntToFloat(Register *target, ASTValue op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue op;
        Type *newt;
    };
    class FloatToInt : public Instruction
    {
    public:
        FloatToInt(Register *target, ASTValue op, Type *newt);
        void accept(InstructionVisitor *v) override;
        Register *target;
        ASTValue op;
        Type *newt;
    };
    class Return : public Instruction
    {
    public:
        Return(Register *value);
        void accept(InstructionVisitor *v) override;
        Register *value;
    };
    class Call : public Instruction
    {
    public:
        Call(Register *reg, Function *f, std::vector<ASTValue> args);
        void accept(InstructionVisitor *v) override;
        Register *reg;
        Function *f;
        std::vector<ASTValue> args;
    };
    class GotoBr : public Br
    {
    public:
        GotoBr(Block *to);
        void accept(BrVisitor *v) override;
        Block *to;
    };
    class CondBr : public Br
    {
    public:
        CondBr(ASTValue v, Block *trueB, Block *falseB);
        void accept(BrVisitor *v) override;
        ASTValue v;
        Block *trueB;
        Block *falseB;
    };
// This code was autogenerated - see the utils/ directory

        // INSTR CLASSES END
    }
}
