#pragma once

#include <memory>
#include <vector>
#include "lex/token.h"
#include "utils/location.h"
#include "utils/ptr.h"
#include "utils/maybe.h"

namespace ASTNS {
// ASTHEADER START
// The following code was autogenerated - see the utils/ directory
    class AST;
    class CUB;
    class Decl;
    class ImplMember;
    class Stmt;
    class Expr;
    class Type;
    class ArgB;
    class ParamB;
    class VStmtIB;
    class PathB;
    class ListB;
    class DeclList;
    class StmtList;
    class ParamList;
    class ArgList;
    class VarStmtItemList;
    class ImplMemberList;
    class PureLocationB;
    class PureLocation;
    class ImplicitDecl;
    class CU;
    class ImplDecl;
    class FunctionDecl;
    class FunctionImplMember;
    class VarStmt;
    class VarStmtItem;
    class ExprStmt;
    class RetStmt;
    class PathType;
    class PointerType;
    class ThisType;
    class Arg;
    class Param;
    class ThisParam;
    class Block;
    class IfExpr;
    class WhileExpr;
    class AssignmentExpr;
    class ShortCircuitExpr;
    class BinaryExpr;
    class CastExpr;
    class UnaryExpr;
    class AddrofExpr;
    class DerefExpr;
    class CallExpr;
    class FieldAccessExpr;
    class MethodCallExpr;
    class PrimaryExpr;
    class PathExpr;
    class Path;
    class AST {
    public:
        AST(File const &file);
        virtual ~AST() {}
        virtual Maybe<Location const> & start() = 0;
        virtual Maybe<Location const> & end() = 0;
        File const &file;
    };
    class CUB : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitCU(NNPtr<ASTNS::CU> ast) = 0;
        };
        virtual ~CUB() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        CUB(File const &file);
    };
    class Decl : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitImplicitDecl(NNPtr<ASTNS::ImplicitDecl> ast) = 0;
            virtual void visitImplDecl(NNPtr<ASTNS::ImplDecl> ast) = 0;
            virtual void visitFunctionDecl(NNPtr<ASTNS::FunctionDecl> ast) = 0;
        };
        virtual ~Decl() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        Decl(File const &file);
    };
    class ImplMember : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitFunctionImplMember(NNPtr<ASTNS::FunctionImplMember> ast) = 0;
        };
        virtual ~ImplMember() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        ImplMember(File const &file);
    };
    class Stmt : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitVarStmt(NNPtr<ASTNS::VarStmt> ast) = 0;
            virtual void visitExprStmt(NNPtr<ASTNS::ExprStmt> ast) = 0;
            virtual void visitRetStmt(NNPtr<ASTNS::RetStmt> ast) = 0;
        };
        virtual ~Stmt() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        Stmt(File const &file);
    };
    class Expr : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitBlock(NNPtr<ASTNS::Block> ast) = 0;
            virtual void visitIfExpr(NNPtr<ASTNS::IfExpr> ast) = 0;
            virtual void visitWhileExpr(NNPtr<ASTNS::WhileExpr> ast) = 0;
            virtual void visitAssignmentExpr(NNPtr<ASTNS::AssignmentExpr> ast) = 0;
            virtual void visitShortCircuitExpr(NNPtr<ASTNS::ShortCircuitExpr> ast) = 0;
            virtual void visitBinaryExpr(NNPtr<ASTNS::BinaryExpr> ast) = 0;
            virtual void visitCastExpr(NNPtr<ASTNS::CastExpr> ast) = 0;
            virtual void visitUnaryExpr(NNPtr<ASTNS::UnaryExpr> ast) = 0;
            virtual void visitAddrofExpr(NNPtr<ASTNS::AddrofExpr> ast) = 0;
            virtual void visitDerefExpr(NNPtr<ASTNS::DerefExpr> ast) = 0;
            virtual void visitCallExpr(NNPtr<ASTNS::CallExpr> ast) = 0;
            virtual void visitFieldAccessExpr(NNPtr<ASTNS::FieldAccessExpr> ast) = 0;
            virtual void visitMethodCallExpr(NNPtr<ASTNS::MethodCallExpr> ast) = 0;
            virtual void visitPrimaryExpr(NNPtr<ASTNS::PrimaryExpr> ast) = 0;
            virtual void visitPathExpr(NNPtr<ASTNS::PathExpr> ast) = 0;
        };
        virtual ~Expr() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        Expr(File const &file);
    };
    class Type : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitPathType(NNPtr<ASTNS::PathType> ast) = 0;
            virtual void visitPointerType(NNPtr<ASTNS::PointerType> ast) = 0;
            virtual void visitThisType(NNPtr<ASTNS::ThisType> ast) = 0;
        };
        virtual ~Type() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        Type(File const &file);
    };
    class ArgB : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitArg(NNPtr<ASTNS::Arg> ast) = 0;
        };
        virtual ~ArgB() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        ArgB(File const &file);
    };
    class ParamB : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitParam(NNPtr<ASTNS::Param> ast) = 0;
            virtual void visitThisParam(NNPtr<ASTNS::ThisParam> ast) = 0;
        };
        virtual ~ParamB() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        ParamB(File const &file);
    };
    class VStmtIB : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitVarStmtItem(NNPtr<ASTNS::VarStmtItem> ast) = 0;
        };
        virtual ~VStmtIB() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        VStmtIB(File const &file);
    };
    class PathB : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitPath(NNPtr<ASTNS::Path> ast) = 0;
        };
        virtual ~PathB() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        PathB(File const &file);
    };
    class ListB : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitDeclList(NNPtr<ASTNS::DeclList> ast) = 0;
            virtual void visitStmtList(NNPtr<ASTNS::StmtList> ast) = 0;
            virtual void visitParamList(NNPtr<ASTNS::ParamList> ast) = 0;
            virtual void visitArgList(NNPtr<ASTNS::ArgList> ast) = 0;
            virtual void visitVarStmtItemList(NNPtr<ASTNS::VarStmtItemList> ast) = 0;
            virtual void visitImplMemberList(NNPtr<ASTNS::ImplMemberList> ast) = 0;
        };
        virtual ~ListB() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        ListB(File const &file);
    };
    class DeclList : public ListB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<Decl>> decls;
        virtual void accept(NNPtr<ASTNS::ListB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        DeclList(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<Decl>> decls);
    };
    class StmtList : public ListB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<Stmt>> stmts;
        virtual void accept(NNPtr<ASTNS::ListB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        StmtList(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<Stmt>> stmts);
    };
    class ParamList : public ListB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<ParamB>> params;
        virtual void accept(NNPtr<ASTNS::ListB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ParamList(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<ParamB>> params);
    };
    class ArgList : public ListB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<Arg>> args;
        virtual void accept(NNPtr<ASTNS::ListB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ArgList(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<Arg>> args);
    };
    class VarStmtItemList : public ListB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<VarStmtItem>> items;
        virtual void accept(NNPtr<ASTNS::ListB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        VarStmtItemList(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<VarStmtItem>> items);
    };
    class ImplMemberList : public ListB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<ImplMember>> members;
        virtual void accept(NNPtr<ASTNS::ListB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ImplMemberList(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<ImplMember>> members);
    };
    class PureLocationB : public AST {
    public:
        class Visitor {
        public:
            virtual ~Visitor() {}
            virtual void visitPureLocation(NNPtr<ASTNS::PureLocation> ast) = 0;
        };
        virtual ~PureLocationB() {}
        virtual void accept(NNPtr<Visitor> v) = 0;
        PureLocationB(File const &file);
    };
    class PureLocation : public PureLocationB {
    public:
        Maybe<Location const> _start, _end;
        int dummy;
        virtual void accept(NNPtr<ASTNS::PureLocationB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        PureLocation(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, int dummy);
    };
    class ImplicitDecl : public Decl {
    public:
        Maybe<Location const> _start, _end;
        int dummy;
        virtual void accept(NNPtr<ASTNS::Decl::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ImplicitDecl(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, int dummy);
    };
    class CU : public CUB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<Decl>> decls;
        virtual void accept(NNPtr<ASTNS::CUB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        CU(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<Decl>> decls);
    };
    class ImplDecl : public Decl {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Type> implFor;
        std::vector<std::unique_ptr<ImplMember>> members;
        virtual void accept(NNPtr<ASTNS::Decl::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ImplDecl(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Type> implFor, std::vector<std::unique_ptr<ImplMember>> members);
    };
    class FunctionDecl : public Decl {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Type> retty;
        Token name;
        std::vector<std::unique_ptr<ParamB>> params;
        std::unique_ptr<Block> body;
        virtual void accept(NNPtr<ASTNS::Decl::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        FunctionDecl(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Type> retty, Token name, std::vector<std::unique_ptr<ParamB>> params, std::unique_ptr<Block> body);
    };
    class FunctionImplMember : public ImplMember {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<FunctionDecl> fun;
        virtual void accept(NNPtr<ASTNS::ImplMember::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        FunctionImplMember(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<FunctionDecl> fun);
    };
    class VarStmt : public Stmt {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<VarStmtItem>> items;
        virtual void accept(NNPtr<ASTNS::Stmt::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        VarStmt(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<VarStmtItem>> items);
    };
    class VarStmtItem : public VStmtIB {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Type> type;
        bool mut;
        Token name;
        Token equal;
        std::unique_ptr<Expr> expr;
        virtual void accept(NNPtr<ASTNS::VStmtIB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        VarStmtItem(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Type> type, bool mut, Token name, Token equal, std::unique_ptr<Expr> expr);
    };
    class ExprStmt : public Stmt {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> expr;
        bool suppress;
        Maybe<Location const> dot;
        virtual void accept(NNPtr<ASTNS::Stmt::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ExprStmt(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> expr, bool suppress, Maybe<Location const> dot);
    };
    class RetStmt : public Stmt {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> expr;
        virtual void accept(NNPtr<ASTNS::Stmt::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        RetStmt(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> expr);
    };
    class PathType : public Type {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Path> path;
        virtual void accept(NNPtr<ASTNS::Type::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        PathType(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Path> path);
    };
    class PointerType : public Type {
    public:
        Maybe<Location const> _start, _end;
        bool mut;
        std::unique_ptr<Type> type;
        virtual void accept(NNPtr<ASTNS::Type::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        PointerType(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, bool mut, std::unique_ptr<Type> type);
    };
    class ThisType : public Type {
    public:
        Maybe<Location const> _start, _end;
        Token th;
        virtual void accept(NNPtr<ASTNS::Type::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ThisType(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, Token th);
    };
    class Arg : public ArgB {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> expr;
        virtual void accept(NNPtr<ASTNS::ArgB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        Arg(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> expr);
    };
    class Param : public ParamB {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Type> type;
        Token name;
        bool mut;
        virtual void accept(NNPtr<ASTNS::ParamB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        Param(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Type> type, Token name, bool mut);
    };
    class ThisParam : public ParamB {
    public:
        Maybe<Location const> _start, _end;
        bool ptr;
        bool mut;
        virtual void accept(NNPtr<ASTNS::ParamB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ThisParam(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, bool ptr, bool mut);
    };
    class Block : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::vector<std::unique_ptr<Stmt>> stmts;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        Block(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<std::unique_ptr<Stmt>> stmts);
    };
    class IfExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        Token iftok;
        Token elsetok;
        std::unique_ptr<Expr> cond;
        std::unique_ptr<Expr> trues;
        std::unique_ptr<Expr> falses;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        IfExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, Token iftok, Token elsetok, std::unique_ptr<Expr> cond, std::unique_ptr<Expr> trues, std::unique_ptr<Expr> falses);
    };
    class WhileExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> cond;
        std::unique_ptr<Expr> body;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        WhileExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> cond, std::unique_ptr<Expr> body);
    };
    class AssignmentExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> target;
        Token equal;
        std::unique_ptr<Expr> expr;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        AssignmentExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> target, Token equal, std::unique_ptr<Expr> expr);
    };
    class ShortCircuitExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> lhs;
        Token op;
        std::unique_ptr<Expr> rhs;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        ShortCircuitExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> lhs, Token op, std::unique_ptr<Expr> rhs);
    };
    class BinaryExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> lhs;
        Token op;
        std::unique_ptr<Expr> rhs;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        BinaryExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> lhs, Token op, std::unique_ptr<Expr> rhs);
    };
    class CastExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Type> type;
        std::unique_ptr<Expr> expr;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        CastExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Type> type, std::unique_ptr<Expr> expr);
    };
    class UnaryExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        Token op;
        std::unique_ptr<Expr> expr;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        UnaryExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, Token op, std::unique_ptr<Expr> expr);
    };
    class AddrofExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        Token op;
        std::unique_ptr<Expr> expr;
        bool mut;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        AddrofExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, Token op, std::unique_ptr<Expr> expr, bool mut);
    };
    class DerefExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        Token op;
        std::unique_ptr<Expr> expr;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        DerefExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, Token op, std::unique_ptr<Expr> expr);
    };
    class CallExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> callee;
        Token oparn;
        std::vector<std::unique_ptr<Arg>> args;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        CallExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> callee, Token oparn, std::vector<std::unique_ptr<Arg>> args);
    };
    class FieldAccessExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> operand;
        Token dot;
        Token field;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        FieldAccessExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> operand, Token dot, Token field);
    };
    class MethodCallExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Expr> operand;
        Token dot;
        Token method;
        Token oparn;
        std::vector<std::unique_ptr<Arg>> args;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        MethodCallExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Expr> operand, Token dot, Token method, Token oparn, std::vector<std::unique_ptr<Arg>> args);
    };
    class PrimaryExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        Token value;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        PrimaryExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, Token value);
    };
    class PathExpr : public Expr {
    public:
        Maybe<Location const> _start, _end;
        std::unique_ptr<Path> path;
        virtual void accept(NNPtr<ASTNS::Expr::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        PathExpr(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::unique_ptr<Path> path);
    };
    class Path : public PathB {
    public:
        Maybe<Location const> _start, _end;
        std::vector<Token> segments;
        virtual void accept(NNPtr<ASTNS::PathB::Visitor> v) override;
        virtual Maybe<Location const> & start() override;
        virtual Maybe<Location const> & end() override;
        Path(File const &file, Maybe<Location const> const &start, Maybe<Location const> const &end, std::vector<Token> segments);
    };
// This code was autogenerated - see the utils/ directory
// ASTHEADER END
}
